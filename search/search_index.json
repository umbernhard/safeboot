{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"safeboot: Booting Linux Safely Goals safeboot has five goals to improve the safety of booting Linux on normal laptops: Booting only code that is authorized by the system owner (by installing a hardware protected platform key for the kernel and initrd) Streamlining the encrypted disk boot process (by storing keys in the TPM, and only unsealing them if the firmware and configuration is unmodified) Reducing the attack surface (by enabling Linux kernel features to enable hardware protection features and to de-privilege the root account) Protecting the runtime system integrity (by optionally booting from a read-only root with dmverity and signed root hash) Proving to remote systems that the local machine is safe (using a remote attestation protocol built with the TPM2) The threat model page has more detail about the firmware, kernel, and runtime changes, as well as how they help achieve these goals and the threats that they help protect against. Why safeboot? The slightly more secure Heads firmware is a better choice for user freedom since it replaces the proprietary firmware with open source. However, Heads and LinuxBoot only support a limited number of mainboards and systems, while safeboot's objective is to work with existing commodity hardware and UEFI SecureBoot mechanisms, as well as relatively stock Linux distributions. The problem is that configuring all of the pieces for UEFI Secure Boot, generating keys in hardware tokens, signing kernels, and integrating LUKS disk encryption with the TPM is very complex. There are numerous guides that walk through individual pieces of this process, but most of them are very fine-grained and require far too many steps to complete. Likewise the tpm2-tools package has all of the low-level API calls for interacting with the TPM and the various endorsement and attestation keys, but no easy way to generate signed quotes and perform remote attestation. Like they say in the informercials: \" there has to be a better way! \" End users and administrators need a tool that wraps up all of the complexity into the few operations that they need from day to day: signing new kernels, decrypting their disks at boot, protecting the system from runtime attackers, attesting to the integrity of their systems, etc. safeboot and tpm2-attest are (early versions of) those tools! Links Installation Instructions for configuring safeboot Threat Model that safeboot is trying to protect against Frequently Asked Questions about safeboot TPM2 Remote Attestation protocol for accessing network resources Chain of Trust for booting a modern x86 CPU Source code safeboot subcommands tpm2-attest subcommands attest-enroll Status","title":"Overview"},{"location":"#safeboot-booting-linux-safely","text":"","title":"safeboot: Booting Linux Safely"},{"location":"#goals","text":"safeboot has five goals to improve the safety of booting Linux on normal laptops: Booting only code that is authorized by the system owner (by installing a hardware protected platform key for the kernel and initrd) Streamlining the encrypted disk boot process (by storing keys in the TPM, and only unsealing them if the firmware and configuration is unmodified) Reducing the attack surface (by enabling Linux kernel features to enable hardware protection features and to de-privilege the root account) Protecting the runtime system integrity (by optionally booting from a read-only root with dmverity and signed root hash) Proving to remote systems that the local machine is safe (using a remote attestation protocol built with the TPM2) The threat model page has more detail about the firmware, kernel, and runtime changes, as well as how they help achieve these goals and the threats that they help protect against.","title":"Goals"},{"location":"#why-safeboot","text":"The slightly more secure Heads firmware is a better choice for user freedom since it replaces the proprietary firmware with open source. However, Heads and LinuxBoot only support a limited number of mainboards and systems, while safeboot's objective is to work with existing commodity hardware and UEFI SecureBoot mechanisms, as well as relatively stock Linux distributions. The problem is that configuring all of the pieces for UEFI Secure Boot, generating keys in hardware tokens, signing kernels, and integrating LUKS disk encryption with the TPM is very complex. There are numerous guides that walk through individual pieces of this process, but most of them are very fine-grained and require far too many steps to complete. Likewise the tpm2-tools package has all of the low-level API calls for interacting with the TPM and the various endorsement and attestation keys, but no easy way to generate signed quotes and perform remote attestation. Like they say in the informercials: \" there has to be a better way! \" End users and administrators need a tool that wraps up all of the complexity into the few operations that they need from day to day: signing new kernels, decrypting their disks at boot, protecting the system from runtime attackers, attesting to the integrity of their systems, etc. safeboot and tpm2-attest are (early versions of) those tools!","title":"Why safeboot?"},{"location":"#links","text":"Installation Instructions for configuring safeboot Threat Model that safeboot is trying to protect against Frequently Asked Questions about safeboot TPM2 Remote Attestation protocol for accessing network resources Chain of Trust for booting a modern x86 CPU Source code safeboot subcommands tpm2-attest subcommands attest-enroll","title":"Links"},{"location":"#status","text":"","title":"Status"},{"location":"attest-enroll/","text":"This script, sbin/attest-enroll implements enrollment of a device into the attestation system using the device's TPM's Endorsement Key's public key ( EKpub ). It takes as arguments an EKpub or the EKpub 's public key in PEM form, and a desired hostname , and it creates the enrollment state for that tuple. Enrollment state consists of: the EKpub the hostname any configured secrets and metadata for that device, with secrets encrypted to the EKpub Secrets are encrypted to the EKpub using sbin/tpm2-send . More on this below . The enrollment database is file based. The directory structure looks like: $DBDIR/??/... # enrollment state for enrolled hosts $DBDIR/${ekhash:0:2}/${ekhash}/ # <- enrollment state for SHA-256(EKpub) $DBDIR/${ekhash:0:2}/${ekhash}/ # <- enrollment state for SHA-256(EKpub) $DBDIR/hostname2ekpub/ # <- index by hostname $DBDIR/hostname2ekpub/${hostname} # <- file containing ${hostname}'s SHA-256(EKpub) $DBDIR/hostname2ekpub/... Configuration is via bash scripts sourced by sbin/attest-enroll : /etc/safeboot-enroll/conf # Principal config file (optional) $DBDIR/attest-enroll.conf # Additional config file (optional) Configuration parameters can also be given on the command-line. See the sbin/attest-enroll usage message for more details. Escrow of Enrolled Secrets If an ESCROW_PUBS_DIR is configured, then every secret subsequently encrypted to any TPM is also encrypted to the defined escrow authorities' public keys: $ESCROW_PUBS_DIR/ # <- EKpubs/PEM of escrow agents here (optional) $ESCROW_PUBS_DIR/someEscrowName.pub # EKpub $ESCROW_PUBS_DIR/otherEscrowName.pem # Public key in PEM form Enrollment State Generation Enrollment state is generated by configured genprog s. Two built-in genprogs are: genhostname -- creates the metadata file recording the hostname, genrootfskey -- creates a 64-byte secret key for root filesystem / volume encryption. Other, external genprog s can be added and configured. The following external genprog s are included: gencert -- creates a private key and a certificate for its public key naming the hostname , genkeytab -- creates a \"keytab\" with the keys for the hostname 's host service Kerberos principal. Sites can provide additional genprog s to generate a large variety of credentials and metadata: PKIX certificates for IPsec, TLS, and/or other purposes OpenSSH host keys and possibly OpenSSH host key certificates Service access tokens Encryption Encryption is implemented by sbin/tpm2-send . Decryption is implemented by sbin/tpm2-recv . Two methods are possible for encryption to a target TPM's EKpub : the \"EK\" method (our name for it) the \"TK\" method (our name for it) Both methods support setting a policy on the ciphertext such that any application using the target's TPM to decrypt it must first execute and satisfy that policy. The \"EK\" method uses TPM2_MakeCredential() via tpm2-tools' tpm2 makecredential command, using the none TCTI (i.e., implemented in software). The target's EKpub is used as the handle input parameter to TPM2_MakeCredential() . A well-known key ( WK ), and the desired policy (if any) are used to compute the cryptographic name of the \"activation object\" ( objectName ) input parameter to TPM2_MakeCredential() . Decryption consists of calling TPM2_ActivateCredential() with the handle to the WK as the activationHandle input parameter, and the EK as the keyHandle input parameter of TPM2_ActivateCredential() . If a policy is desired then the adminWithPolicy attribute will be set on the WKname , which will cause TPM2_ActivateCredential() to require that the policy be satisfied. The \"TK\" method uses TPM2_Duplicate() via tpm2-tools' tpm2 duplicate command using the none TCTI (i.e., implemented in software. An RSA keypair is generated and its private key is exported to the target TPM using TPM2_Duplicate() -- we call this the \"transport key\", the TK . The small secret will then be encrypted to the TK 's public key ( TKpub ). Decryption works by importing the exported TK and then using TPM2_RSA_Decrypt() to decrypt the small secret encrypted to the TKpub . Encryption of Larger Secrets In all cases, regardless of a secret's size, we use sbin/tpm2-send to encrypt an ephemeral, random AES-256 key to the target's TPM, then we encrypt the actual secret in that AES key in confounded AES-256-CBC-HMAC-SHA-256 cipher mode. The final ciphertext consists of those two ciphertexts: the one generated by sbin/tpm2-send and the one generated by AES encryption. Encryption using the confounded AES-256-CBC-HMAC-SHA-256 cipher mode consists of: prepending a full cipher block of random bits (the \"confounder\") to the plaintext, encrypting the plaintext in AES-256 in cipher block chaining (CBC) mode with padding and zero IV, appending the HMAC of the resulting ciphertext using SHA-256 as the hash function for HMAC. Decryption using the confounded AES-256-CBC-HMAC-SHA-256 cipher mode consists of: computing the HMAC-SHA-256 of the ciphertext excluding the MAC, checking that the HMAC of the ciphertext matches the HMAC in the ciphertext, decryption of the ciphertext using AES-256 in CBC with zero IV, removing the first full cipher block of the plaintext (the \"confounder\"), removing the padding. The confounder serves mainly to function as a sort of explicit random IV while allowing us to use a zero IV in the openssl enc command invocations. Since all of this is implemented in bash with openssl , and OpenSSL does not provide a decent authenticated encryption mode for AES, we script the confounded AES-256-CBC-HMAC-SHA-256 cipher mode, which turns out to be simple and elegant in bash. With OpenSSL 3.0 we could use ciphertext stealing mode (CTS) instead of CBC, and then we'd be using exactly the same more as Kerberos uses (confounded CTS with HMAC). The CTS cipher mode is a variant of CBC mode that avoids the need for padding, in exchange for which advantage CTS requires plaintexts to be at least one full cipher block (16 bytes) long, thus CTS is always used with a confounder, and the confounder functions as an explicit IV that allows the external IV to be zero.","title":"attest-enroll: enrolling a device for TPM2 remote attestation"},{"location":"attest-enroll/#escrow-of-enrolled-secrets","text":"If an ESCROW_PUBS_DIR is configured, then every secret subsequently encrypted to any TPM is also encrypted to the defined escrow authorities' public keys: $ESCROW_PUBS_DIR/ # <- EKpubs/PEM of escrow agents here (optional) $ESCROW_PUBS_DIR/someEscrowName.pub # EKpub $ESCROW_PUBS_DIR/otherEscrowName.pem # Public key in PEM form","title":"Escrow of Enrolled Secrets"},{"location":"attest-enroll/#enrollment-state-generation","text":"Enrollment state is generated by configured genprog s. Two built-in genprogs are: genhostname -- creates the metadata file recording the hostname, genrootfskey -- creates a 64-byte secret key for root filesystem / volume encryption. Other, external genprog s can be added and configured. The following external genprog s are included: gencert -- creates a private key and a certificate for its public key naming the hostname , genkeytab -- creates a \"keytab\" with the keys for the hostname 's host service Kerberos principal. Sites can provide additional genprog s to generate a large variety of credentials and metadata: PKIX certificates for IPsec, TLS, and/or other purposes OpenSSH host keys and possibly OpenSSH host key certificates Service access tokens","title":"Enrollment State Generation"},{"location":"attest-enroll/#encryption","text":"Encryption is implemented by sbin/tpm2-send . Decryption is implemented by sbin/tpm2-recv . Two methods are possible for encryption to a target TPM's EKpub : the \"EK\" method (our name for it) the \"TK\" method (our name for it) Both methods support setting a policy on the ciphertext such that any application using the target's TPM to decrypt it must first execute and satisfy that policy. The \"EK\" method uses TPM2_MakeCredential() via tpm2-tools' tpm2 makecredential command, using the none TCTI (i.e., implemented in software). The target's EKpub is used as the handle input parameter to TPM2_MakeCredential() . A well-known key ( WK ), and the desired policy (if any) are used to compute the cryptographic name of the \"activation object\" ( objectName ) input parameter to TPM2_MakeCredential() . Decryption consists of calling TPM2_ActivateCredential() with the handle to the WK as the activationHandle input parameter, and the EK as the keyHandle input parameter of TPM2_ActivateCredential() . If a policy is desired then the adminWithPolicy attribute will be set on the WKname , which will cause TPM2_ActivateCredential() to require that the policy be satisfied. The \"TK\" method uses TPM2_Duplicate() via tpm2-tools' tpm2 duplicate command using the none TCTI (i.e., implemented in software. An RSA keypair is generated and its private key is exported to the target TPM using TPM2_Duplicate() -- we call this the \"transport key\", the TK . The small secret will then be encrypted to the TK 's public key ( TKpub ). Decryption works by importing the exported TK and then using TPM2_RSA_Decrypt() to decrypt the small secret encrypted to the TKpub .","title":"Encryption"},{"location":"attest-enroll/#encryption-of-larger-secrets","text":"In all cases, regardless of a secret's size, we use sbin/tpm2-send to encrypt an ephemeral, random AES-256 key to the target's TPM, then we encrypt the actual secret in that AES key in confounded AES-256-CBC-HMAC-SHA-256 cipher mode. The final ciphertext consists of those two ciphertexts: the one generated by sbin/tpm2-send and the one generated by AES encryption. Encryption using the confounded AES-256-CBC-HMAC-SHA-256 cipher mode consists of: prepending a full cipher block of random bits (the \"confounder\") to the plaintext, encrypting the plaintext in AES-256 in cipher block chaining (CBC) mode with padding and zero IV, appending the HMAC of the resulting ciphertext using SHA-256 as the hash function for HMAC. Decryption using the confounded AES-256-CBC-HMAC-SHA-256 cipher mode consists of: computing the HMAC-SHA-256 of the ciphertext excluding the MAC, checking that the HMAC of the ciphertext matches the HMAC in the ciphertext, decryption of the ciphertext using AES-256 in CBC with zero IV, removing the first full cipher block of the plaintext (the \"confounder\"), removing the padding. The confounder serves mainly to function as a sort of explicit random IV while allowing us to use a zero IV in the openssl enc command invocations. Since all of this is implemented in bash with openssl , and OpenSSL does not provide a decent authenticated encryption mode for AES, we script the confounded AES-256-CBC-HMAC-SHA-256 cipher mode, which turns out to be simple and elegant in bash. With OpenSSL 3.0 we could use ciphertext stealing mode (CTS) instead of CBC, and then we'd be using exactly the same more as Kerberos uses (confounded CTS with HMAC). The CTS cipher mode is a variant of CBC mode that avoids the need for padding, in exchange for which advantage CTS requires plaintexts to be at least one full cipher block (16 bytes) long, thus CTS is always used with a confounder, and the confounder functions as an explicit IV that allows the external IV to be zero.","title":"Encryption of Larger Secrets"},{"location":"attestation/","text":"When the user wants to connect to another computer over the network, they typicaly authenticate with a password and some sort of two factor token to prove to the remote system that they are authorized to make the connection. In high assurance applications, however, it is also important that the local computer be able to attest to the remote server that the local computer itself is both authorized and is also in a known configuration. The TPM provides a mechanism to do this sort of remote attestation, similar to the way that the disk encryption keys are \" sealed \" based on the PCRs and only decrypted if the platform configuration matches the sealed values. The tpm2-tools package has many of the pieces, but it is at too low a level for humans to use. Other parts of the validation exist in the openssl package, but again are not easily used and require format conversions from the TPM formats. tpm2-attest attempts to wrap all of the various parts of those two packages into a simple script that provides the four main attestation functions: sign a quote, validate a signed quote, seal a secret for a specific TPM, and unseal it with that TPM. Related to this is attest-enroll , a script that enrolls a device (e.g., a laptop, a server, etc.) given just its TPM's endorsement key's public key ( EKpub ) and a name. Enrollment can produce and encrypt to that EKpub any number of long-term secrets that are later sent to that device during successful attestation. tl;dr Enroll: extract EKpub , pick a device name run attest-enroll (typically via an HTTP API) with that EKpub and name Attest: Client: tpm2-attest > quote.tar Client: Send quote.tar to server (typically via an HTTP API) Server: tpm2-attest verify quote.tar | attest-verify to verify the client's state Server: tpm2-attest seal quote.tar < enrolled-secrets.tar > cipher.bin Server: Send cipher.bin to client Client: tpm2-attest unseal < cipher.bin > enrolled-secrets.tar Client: use tpm2-recv to decrypt long-term secrets in enrolled-secrets.tar Attestation protocol sequenceDiagram participant TPM participant Client participant Server as Attestation Server participant DB as Attestation Database TPM->>Client: EK, AK, Quote Client->>Server: EK, AK, Quote, eventlog Server->>DB: Hash EKpub, eventlog DB->>Server: TK and encrypted data Server->>Client: reply.tar: CK, TK, data Client->>TPM: activatecredential with AK TPM->>Client: Decrypted CK Client->>TPM: Load TK Client->>TPM: TK Encrypted data TPM->>Client: Decrypted data Client->>Server: Success The protocol requires a one round-trip between the local machine (the client) and the remote attestation server), and all comunication between the Client and the Server can be in the clear. There is no sensitive data exchanged -- the quote.tar file contains only public keys and PCR values that are essentially public, and the cipher.bin reply is encrypted with the TPM's Endorsement Key, so it should only be unsealable by that specific TPM. A MITM could substitute a different EK/AK pair, although this does not allow them to masquarade as the TPM of the attesting machine since they do not have the EK for that TPM, and the real TPM won't be able to decrypt the response from the attestation server since it would be encrypted with the wrong EK. The keys involved are: CA Root, stored hopefully securely by the CA TPM Manufacturer key, a signing-only key signed by the CA Root, and stored hopefully securely by the OEM TPM Endorsement key ( EK ), an encryption key, generated in the TPM(?) and stored in the TPM hardware device TPM Endorsement certificate ( ek.crt ), signed by the TPM manufacturer, often stored in the TPM NVRAM Attestation Key ( AK ), a ephemeral signing-only key generated by the TPM, but not signed by it (for inexplicable reasons), used to sign the PCR quotes Credential Key ( CK ), an ephemeral symmetric encryption key used to protect the reply from the server, encrypted with the EK and tied to the AK so that only that TPM will decrypt it, and only if the AK is a valid key. Transport Key ( TK ), a long-term TPM duplicate key used to protect the attestation data. It is stored in the attestation database and encrypted with the client machine's EK , and has a policy that allows it to be used only once. There are two protocols: enrollment, and attestation. Each protocol is one round trip. Enrollment sequenceDiagram participant Admin participant Server as Enrollment Server participant DB as Attestation Database Admin->>Server: client 'EKpub'<br/> `EKcert`<br/> hostname<br/> Other data Note right of Server: validate `EKpub` against `EKcert`<br/> Generate TK Server->>DB: `EKpub`<br/> hostname<br/> `TK` (encrypted with `EK`) Note left of DB: Indexed by `sha256(EKpub)` An administrator, or the client itself, sends the client's EKpub and desired hostname to the enrollment server. The enrollment server checks that the client's enrolled state does not exist, then it creates it. See sbin/attest-enroll . The enrolled state consists of secrets encrypted to the client's EKpub and cleartext metadata. Attestation sequenceDiagram participant TPM participant Client participant Server as Attestation Server TPM->>Client: EKpub, Ephemeral AK Client->>TPM: Time since epoch TPM->>Client: Quote of all PCRs and time, signed with AK Note right of Client: Extract eventlog Client->>Server: quote.tar:<br/>EKpub and cert<br/> AK<br/> Quote (signed with AK)<br/> eventlog Client creates an Attestation Key ( AK ), quotes all the PCRs and current time, and sends its EKpub , AKpub , quote, and eventlog to the server. This is done with tpm2-attest quote > quote.tar sequenceDiagram participant Client participant Server as Attestation Server participant DB as Attestation Database Client->>Server: quote.tar Note right of Server: Validate signature on Quote Note right of Server: Validate eventlog matches quote Note right of Server: Validate time stamp is recent Server->>DB: Hash EKpub, eventlog Note left of DB: Validate policy on eventlog and PCRs DB->>Server: TK (encrypted with EK)<br/> Attestation data (encrypted with TK) Note right of Server: Create ephemeral credential key CK Note right of Server: Encrypt TK (encrypted with EK) with CK Note right of Server: makecredential with EK+AK and CK (no TPM required) Server->>Client: reply.tar:<br/>Credential blob<br/>(CK, encrypted with the EK / AK)<br/> TK encrypted with EK and credential key<br/> Attestation data (encrypted with TK) The server checks the quote, calls TPM2_MakeCredential() with the AKpub as the activation object, the EKpub as the key to encrypt to, and an AES-256 session key, and sends back the output as well as the enrolled state encrypted in that AES-256 session key. This is done with tpm2-attest verify | attest-verify | tpm2-attest seal sequenceDiagram participant TPM participant Client participant Server as Attestation Server Server->>Client: reply.tar Client->>TPM: activatecredential with AK Note right of TPM: validate AK, decrypt with EK TPM->>Client: Unsealed CK Note right of Client: Decrypt TK (encrypted with EK) with CK Client->>TPM: Load TK (encrypted with EK) TPM->>Client: TK context Client->>TPM: TK policy<br> Attestation data encrypted with TK Note right of TPM: validate TK policy<br>Decrypt data with TK TPM->>Client: Decrypted attestation data Client->>Server: Optionally report success The client recovers the AES-256 session key using TPM2_ActivateCredential() and then decrypts the secrets in its enrolled state. This is done with: tpm2-attest unseal then tpm2-recv for each secret. An optional second round-trip allows the client to prove possession of the EK and AK , and this can be used for logging the client's attestation status. Quote validation When the Server receives the quote file from the client, it runs: tpm2-attest verify quote.tar $nonce With this command the server will: Validates the SSL certificate chain on the client TPM EK cert to ensure that it came from a real TPM Validates that the quote is signed by the AK with the correct nonce (if the nonce is not checked, then this could be a replay attack by the Client) Server optionally consults its list of previously enrolled devices to verify that this EK is in an owner controlled machine Server optionally validates that the PCRs match the expected values Server optoinally validates that the TPM event log produces the set of PCR values in the quote If the command fails, then something is likely wrong on the Client side and requires remediation. The Server should not proceed to sealing a secret for the Client. Suprisingly, the Attestation Key is not signed by the Endorsement Key, so the Server has to check the EK certificate to ensure that it came from a real TPM. Additional, the Server must check the AK attributes to ensure that it has fixedtpm and sensitivedataorigin set, which indicates that the AK was generated inside the TPM. Even with these checks, the Server is still trusting that the TPM hardware implements tpm2_activatecredential with all of these checks correctly done, since the sealed data is encrypted with the EK, not the AK. (Like many things with the TPM2, this is a really baroque way to organize the keys). Secret sealing Assuming the validation passed, the server can seal secret data such that only the TPM that produced the signed attestation will be able to unseal it, and has faith that the TPM will not unseal it if it has been reset (to prevent attacks that reboot into untrusted firmware): cat secret.txt | tpm2-attest seal quote.tar > cipher.bin With this command the Server will: Encrypt a secret message (which could be a disk encryption key, a network access token, or whatever) with the TPM's EK, along with the hash of the AK. The Server then sends this encrypted blob to the Client. Note that there is a verify-and-seal that combines both the quote validation and the sealing of the data to the attestation key in one step: cat secret.txt | tpm2-attest seal quote.tar $nonce > cipher.bin Secret unsealing Once the Client receives the sealed blob from the Server, it attempts to unseal it with the Attestation Key context that is left over from the initial quote signing: cat cipher.bin | tpm2-attest unseal ak.ctx > secret.txt With this command, the Client and TPM will: Initiates an encrypted session with the TPM and sends the blob to it. The TPM checks that the hash of the AK matches one that it generated and that it hasn't rebooted since then. If these checks pass, the TPM uses its private EK to decrypt the blob. Client receives the secret message over the encrypted channel to the TPM At this point the Client can use the shared secret to authenticate to the Server, a network, or decrypt it's disk, or whatever. The TPM is no longer involved. TPM OEM Certificates A key part of the remote attestion is being able to trust that the TPM hardware is produced by a TPM manufacturer. Much like SSL Certs for websites, the TPM's Endorsement Key is signed by the OEM with their Intermediate CA, which is signed by a Root CA. Unlike SSL, the Root CAs are often not in the system's /etc/ssl/certs/ directory, and not easily accessible online. Some OEMs publish them in datasheets ( ST TPM EK certificates ), some have online portals to select per-device intermediate certs ( Infineon Optiga certificates ), and some just say \" Contact manufacturer for more details \" ( Atmel/Microchip EK Configuration ). Luckily Microsoft has a CAB file with all of their approved TPM OEMs in their guide to setting up shielded VMs . These x509 certs are in DER format ( and have a few odd ones ), so they have been converted to PEM and bundled into /etc/safeboot/certs/ for validating the TPM attestations. Adding new intermediate certificates If you add your own TPM keys to the directory, you will need to re-build the symlinks that OpenSSL uses for the -CApath : c_rehash /etc/safeboot/certs/ TPMs without EK certificates Unfortunately not all TPMs store their EK certs in the NVRAM; some of them require an online query to the OEM to generate the certificate. There is the tpm2_getmanufec program that is supposed to help with this process, although it hasn't been integrated into this tool yet. An alternative is to sign the EK with a key under your own control with tpm2-attest ek-sign . This will produce ek.crt , signed with the safeboot key. The signing operation can be done out-of-band on a different machine. Usually the EK public components can be extracted from the TPM, signed, and the resulting signed ek.crt can be stored back into the TPM nvram. Note that this will erase an existing OEM cert if you have one! tpm2 createek -c /dev/null -f PEM -u ek.pem tpm2-attest ek-sign < ek.pem > ek.crt /CN=device/OU=example.org/ tpm2 nvdefine -s 1500 0x1c00002 tpm2 nvwrite -i ek.crt 0x1c00002 Google Cloud's ShieldedVM service enables vTPM for the guests, although it does not provide an EK in the NVRAM either. The key can be retrieved out of band with these instructions , or the public component can be read from the tpm2 createek command described above. Using the Google Cloud ShieldedVM lookup service can function as an EKcert as far as establishing trust in an instance's vTPM. Remote attestation demo Since the quote does not contain any clear text information and the response is sealed specifically for the TPM that generated the quote, a simple http server can be used to perform the attestion verification. A demo in sbin/attest-server performs this, using a fixed set of PCRs and a table of public key to secret mappings for the listed endorsement keys. On the server run: ./sbin/attest-server secrets.yaml And on the client: tpm2-attest attest http://server-name/ \\ > /tmp/secret.txt \\ || echo \"failed!\" FAQ Why is this a shell script? It is often desirable to perform a remote attestion inside of an initrd , where there aren't fancy runtimes for Python or more advanced languages. So the quote generation needs to be written assuming very limited resources, as does the response unsealing. The remote attestation server side could be implemented entirely in a more civilized language, especially since the Server does not require any TPM interaction at all -- all of its work is done in software and can be run as an ordinary user. As an example of moving some functionality into better languages, the tpm2-eventlog-validate tool that parses the TPM2 event log and generates expected PCR values is written in Python. I thought remote attestation and TPMs were only for DRM? One of the big fears in the free software community was that TPM's would be used to lockdown the devices and implement DRM. That hasn't developed in general purpose computers and mjg59's TPM guide concludes with \" the current state of technology doesn't make them useful for practical limitations of end-user freedom \". There's a far bigger threat to user freedom in the locked-down world of mobile devices; currently most x86 machines allow rekeying with user keys, so the software (but not the firmware) is still under owner control. Remote Attestation can be used bidirectionally as well - it allows the server to attest to the client that the machine is in a trustworthy state. This is perhaps an even more valuable use case: you might have fairly tight physical control of your personal machine, but a bare metal server in a data center is potentially open to attacks by the cloud operator as well as the previous tenants. Having attestations as to the firmware and the OS configuration can make it more trustable. Why is generating a quote so slow? There is lots of traffic between the tpm2-attest program and the TPM during the attestation process, and the TPM is not a fast device. Read the Endorsement Key (EK) and EK Certificate take a few hundred miliseconds, signing the quote takes another few hundred, etc. The process used to take around 20 seconds, since the TPM had to generate a new RSA Attestation Key (AK) to sign the PCR quote, and generating an RSA key requires finding large primes with certain values. The AK was replaced with ECC, which is much faster to generate. Creating a new one each time should not be necessary; several attestation protocols use a pregenerated AK that is persistent in the TPM, except that opens up a race condition between generating a quote and receiving the sealed data. The quote includes the reboot count, but the sealed data does not reference it, so the TPM will unseal it if the AK is still valid, even if an attacker has rebooted into an untrustworthy state inbetween generating the quote and receiving the sealed response. By creating an ephemeral AK (with the stclear bit set in the attributes), the TPM will not allow it to be persisted and will refuse to reload it when the reboot counter increments. Discrete TPM vs fTPM? The Discrete TPM is potentially a hardware weakpoint; a physically proximate adversary could remove the TPM from a machine and connect it to an untrusted device and then masquarade as the device to which the TPM had been connected. This would also potentially allow them to extract any sealed disk encryption keys, as described on the threat model page , and is one of the advantages of an fTPM inside the Management Engine. A proximate attacker could also interfere with the LPC or i2c bus of a Discrete TPM using something like the TPM Genie , which allow them to both modify the hashes sent to the TPM during PCR extension operations, and read the unsealed secrets when they are returned if the TPM didn't support secret sessions. However, the fTPM is a pure-software application inside the ME and potentially allows an attacker with code execution on the ME to find the sealing secrets that are used to protect the TPM keys in the ME NVRAM, which would allow attacks against the quoting and attestation process.","title":"Remote Attestation"},{"location":"attestation/#tldr","text":"Enroll: extract EKpub , pick a device name run attest-enroll (typically via an HTTP API) with that EKpub and name Attest: Client: tpm2-attest > quote.tar Client: Send quote.tar to server (typically via an HTTP API) Server: tpm2-attest verify quote.tar | attest-verify to verify the client's state Server: tpm2-attest seal quote.tar < enrolled-secrets.tar > cipher.bin Server: Send cipher.bin to client Client: tpm2-attest unseal < cipher.bin > enrolled-secrets.tar Client: use tpm2-recv to decrypt long-term secrets in enrolled-secrets.tar","title":"tl;dr"},{"location":"attestation/#attestation-protocol","text":"sequenceDiagram participant TPM participant Client participant Server as Attestation Server participant DB as Attestation Database TPM->>Client: EK, AK, Quote Client->>Server: EK, AK, Quote, eventlog Server->>DB: Hash EKpub, eventlog DB->>Server: TK and encrypted data Server->>Client: reply.tar: CK, TK, data Client->>TPM: activatecredential with AK TPM->>Client: Decrypted CK Client->>TPM: Load TK Client->>TPM: TK Encrypted data TPM->>Client: Decrypted data Client->>Server: Success The protocol requires a one round-trip between the local machine (the client) and the remote attestation server), and all comunication between the Client and the Server can be in the clear. There is no sensitive data exchanged -- the quote.tar file contains only public keys and PCR values that are essentially public, and the cipher.bin reply is encrypted with the TPM's Endorsement Key, so it should only be unsealable by that specific TPM. A MITM could substitute a different EK/AK pair, although this does not allow them to masquarade as the TPM of the attesting machine since they do not have the EK for that TPM, and the real TPM won't be able to decrypt the response from the attestation server since it would be encrypted with the wrong EK. The keys involved are: CA Root, stored hopefully securely by the CA TPM Manufacturer key, a signing-only key signed by the CA Root, and stored hopefully securely by the OEM TPM Endorsement key ( EK ), an encryption key, generated in the TPM(?) and stored in the TPM hardware device TPM Endorsement certificate ( ek.crt ), signed by the TPM manufacturer, often stored in the TPM NVRAM Attestation Key ( AK ), a ephemeral signing-only key generated by the TPM, but not signed by it (for inexplicable reasons), used to sign the PCR quotes Credential Key ( CK ), an ephemeral symmetric encryption key used to protect the reply from the server, encrypted with the EK and tied to the AK so that only that TPM will decrypt it, and only if the AK is a valid key. Transport Key ( TK ), a long-term TPM duplicate key used to protect the attestation data. It is stored in the attestation database and encrypted with the client machine's EK , and has a policy that allows it to be used only once. There are two protocols: enrollment, and attestation. Each protocol is one round trip.","title":"Attestation protocol"},{"location":"attestation/#enrollment","text":"sequenceDiagram participant Admin participant Server as Enrollment Server participant DB as Attestation Database Admin->>Server: client 'EKpub'<br/> `EKcert`<br/> hostname<br/> Other data Note right of Server: validate `EKpub` against `EKcert`<br/> Generate TK Server->>DB: `EKpub`<br/> hostname<br/> `TK` (encrypted with `EK`) Note left of DB: Indexed by `sha256(EKpub)` An administrator, or the client itself, sends the client's EKpub and desired hostname to the enrollment server. The enrollment server checks that the client's enrolled state does not exist, then it creates it. See sbin/attest-enroll . The enrolled state consists of secrets encrypted to the client's EKpub and cleartext metadata.","title":"Enrollment"},{"location":"attestation/#attestation","text":"sequenceDiagram participant TPM participant Client participant Server as Attestation Server TPM->>Client: EKpub, Ephemeral AK Client->>TPM: Time since epoch TPM->>Client: Quote of all PCRs and time, signed with AK Note right of Client: Extract eventlog Client->>Server: quote.tar:<br/>EKpub and cert<br/> AK<br/> Quote (signed with AK)<br/> eventlog Client creates an Attestation Key ( AK ), quotes all the PCRs and current time, and sends its EKpub , AKpub , quote, and eventlog to the server. This is done with tpm2-attest quote > quote.tar sequenceDiagram participant Client participant Server as Attestation Server participant DB as Attestation Database Client->>Server: quote.tar Note right of Server: Validate signature on Quote Note right of Server: Validate eventlog matches quote Note right of Server: Validate time stamp is recent Server->>DB: Hash EKpub, eventlog Note left of DB: Validate policy on eventlog and PCRs DB->>Server: TK (encrypted with EK)<br/> Attestation data (encrypted with TK) Note right of Server: Create ephemeral credential key CK Note right of Server: Encrypt TK (encrypted with EK) with CK Note right of Server: makecredential with EK+AK and CK (no TPM required) Server->>Client: reply.tar:<br/>Credential blob<br/>(CK, encrypted with the EK / AK)<br/> TK encrypted with EK and credential key<br/> Attestation data (encrypted with TK) The server checks the quote, calls TPM2_MakeCredential() with the AKpub as the activation object, the EKpub as the key to encrypt to, and an AES-256 session key, and sends back the output as well as the enrolled state encrypted in that AES-256 session key. This is done with tpm2-attest verify | attest-verify | tpm2-attest seal sequenceDiagram participant TPM participant Client participant Server as Attestation Server Server->>Client: reply.tar Client->>TPM: activatecredential with AK Note right of TPM: validate AK, decrypt with EK TPM->>Client: Unsealed CK Note right of Client: Decrypt TK (encrypted with EK) with CK Client->>TPM: Load TK (encrypted with EK) TPM->>Client: TK context Client->>TPM: TK policy<br> Attestation data encrypted with TK Note right of TPM: validate TK policy<br>Decrypt data with TK TPM->>Client: Decrypted attestation data Client->>Server: Optionally report success The client recovers the AES-256 session key using TPM2_ActivateCredential() and then decrypts the secrets in its enrolled state. This is done with: tpm2-attest unseal then tpm2-recv for each secret. An optional second round-trip allows the client to prove possession of the EK and AK , and this can be used for logging the client's attestation status.","title":"Attestation"},{"location":"attestation/#quote-validation","text":"When the Server receives the quote file from the client, it runs: tpm2-attest verify quote.tar $nonce With this command the server will: Validates the SSL certificate chain on the client TPM EK cert to ensure that it came from a real TPM Validates that the quote is signed by the AK with the correct nonce (if the nonce is not checked, then this could be a replay attack by the Client) Server optionally consults its list of previously enrolled devices to verify that this EK is in an owner controlled machine Server optionally validates that the PCRs match the expected values Server optoinally validates that the TPM event log produces the set of PCR values in the quote If the command fails, then something is likely wrong on the Client side and requires remediation. The Server should not proceed to sealing a secret for the Client. Suprisingly, the Attestation Key is not signed by the Endorsement Key, so the Server has to check the EK certificate to ensure that it came from a real TPM. Additional, the Server must check the AK attributes to ensure that it has fixedtpm and sensitivedataorigin set, which indicates that the AK was generated inside the TPM. Even with these checks, the Server is still trusting that the TPM hardware implements tpm2_activatecredential with all of these checks correctly done, since the sealed data is encrypted with the EK, not the AK. (Like many things with the TPM2, this is a really baroque way to organize the keys).","title":"Quote validation"},{"location":"attestation/#secret-sealing","text":"Assuming the validation passed, the server can seal secret data such that only the TPM that produced the signed attestation will be able to unseal it, and has faith that the TPM will not unseal it if it has been reset (to prevent attacks that reboot into untrusted firmware): cat secret.txt | tpm2-attest seal quote.tar > cipher.bin With this command the Server will: Encrypt a secret message (which could be a disk encryption key, a network access token, or whatever) with the TPM's EK, along with the hash of the AK. The Server then sends this encrypted blob to the Client. Note that there is a verify-and-seal that combines both the quote validation and the sealing of the data to the attestation key in one step: cat secret.txt | tpm2-attest seal quote.tar $nonce > cipher.bin","title":"Secret sealing"},{"location":"attestation/#secret-unsealing","text":"Once the Client receives the sealed blob from the Server, it attempts to unseal it with the Attestation Key context that is left over from the initial quote signing: cat cipher.bin | tpm2-attest unseal ak.ctx > secret.txt With this command, the Client and TPM will: Initiates an encrypted session with the TPM and sends the blob to it. The TPM checks that the hash of the AK matches one that it generated and that it hasn't rebooted since then. If these checks pass, the TPM uses its private EK to decrypt the blob. Client receives the secret message over the encrypted channel to the TPM At this point the Client can use the shared secret to authenticate to the Server, a network, or decrypt it's disk, or whatever. The TPM is no longer involved.","title":"Secret unsealing"},{"location":"attestation/#tpm-oem-certificates","text":"A key part of the remote attestion is being able to trust that the TPM hardware is produced by a TPM manufacturer. Much like SSL Certs for websites, the TPM's Endorsement Key is signed by the OEM with their Intermediate CA, which is signed by a Root CA. Unlike SSL, the Root CAs are often not in the system's /etc/ssl/certs/ directory, and not easily accessible online. Some OEMs publish them in datasheets ( ST TPM EK certificates ), some have online portals to select per-device intermediate certs ( Infineon Optiga certificates ), and some just say \" Contact manufacturer for more details \" ( Atmel/Microchip EK Configuration ). Luckily Microsoft has a CAB file with all of their approved TPM OEMs in their guide to setting up shielded VMs . These x509 certs are in DER format ( and have a few odd ones ), so they have been converted to PEM and bundled into /etc/safeboot/certs/ for validating the TPM attestations.","title":"TPM OEM Certificates"},{"location":"attestation/#adding-new-intermediate-certificates","text":"If you add your own TPM keys to the directory, you will need to re-build the symlinks that OpenSSL uses for the -CApath : c_rehash /etc/safeboot/certs/","title":"Adding new intermediate certificates"},{"location":"attestation/#tpms-without-ek-certificates","text":"Unfortunately not all TPMs store their EK certs in the NVRAM; some of them require an online query to the OEM to generate the certificate. There is the tpm2_getmanufec program that is supposed to help with this process, although it hasn't been integrated into this tool yet. An alternative is to sign the EK with a key under your own control with tpm2-attest ek-sign . This will produce ek.crt , signed with the safeboot key. The signing operation can be done out-of-band on a different machine. Usually the EK public components can be extracted from the TPM, signed, and the resulting signed ek.crt can be stored back into the TPM nvram. Note that this will erase an existing OEM cert if you have one! tpm2 createek -c /dev/null -f PEM -u ek.pem tpm2-attest ek-sign < ek.pem > ek.crt /CN=device/OU=example.org/ tpm2 nvdefine -s 1500 0x1c00002 tpm2 nvwrite -i ek.crt 0x1c00002 Google Cloud's ShieldedVM service enables vTPM for the guests, although it does not provide an EK in the NVRAM either. The key can be retrieved out of band with these instructions , or the public component can be read from the tpm2 createek command described above. Using the Google Cloud ShieldedVM lookup service can function as an EKcert as far as establishing trust in an instance's vTPM.","title":"TPMs without EK certificates"},{"location":"attestation/#remote-attestation-demo","text":"Since the quote does not contain any clear text information and the response is sealed specifically for the TPM that generated the quote, a simple http server can be used to perform the attestion verification. A demo in sbin/attest-server performs this, using a fixed set of PCRs and a table of public key to secret mappings for the listed endorsement keys. On the server run: ./sbin/attest-server secrets.yaml And on the client: tpm2-attest attest http://server-name/ \\ > /tmp/secret.txt \\ || echo \"failed!\"","title":"Remote attestation demo"},{"location":"attestation/#faq","text":"","title":"FAQ"},{"location":"attestation/#why-is-this-a-shell-script","text":"It is often desirable to perform a remote attestion inside of an initrd , where there aren't fancy runtimes for Python or more advanced languages. So the quote generation needs to be written assuming very limited resources, as does the response unsealing. The remote attestation server side could be implemented entirely in a more civilized language, especially since the Server does not require any TPM interaction at all -- all of its work is done in software and can be run as an ordinary user. As an example of moving some functionality into better languages, the tpm2-eventlog-validate tool that parses the TPM2 event log and generates expected PCR values is written in Python.","title":"Why is this a shell script?"},{"location":"attestation/#i-thought-remote-attestation-and-tpms-were-only-for-drm","text":"One of the big fears in the free software community was that TPM's would be used to lockdown the devices and implement DRM. That hasn't developed in general purpose computers and mjg59's TPM guide concludes with \" the current state of technology doesn't make them useful for practical limitations of end-user freedom \". There's a far bigger threat to user freedom in the locked-down world of mobile devices; currently most x86 machines allow rekeying with user keys, so the software (but not the firmware) is still under owner control. Remote Attestation can be used bidirectionally as well - it allows the server to attest to the client that the machine is in a trustworthy state. This is perhaps an even more valuable use case: you might have fairly tight physical control of your personal machine, but a bare metal server in a data center is potentially open to attacks by the cloud operator as well as the previous tenants. Having attestations as to the firmware and the OS configuration can make it more trustable.","title":"I thought remote attestation and TPMs were only for DRM?"},{"location":"attestation/#why-is-generating-a-quote-so-slow","text":"There is lots of traffic between the tpm2-attest program and the TPM during the attestation process, and the TPM is not a fast device. Read the Endorsement Key (EK) and EK Certificate take a few hundred miliseconds, signing the quote takes another few hundred, etc. The process used to take around 20 seconds, since the TPM had to generate a new RSA Attestation Key (AK) to sign the PCR quote, and generating an RSA key requires finding large primes with certain values. The AK was replaced with ECC, which is much faster to generate. Creating a new one each time should not be necessary; several attestation protocols use a pregenerated AK that is persistent in the TPM, except that opens up a race condition between generating a quote and receiving the sealed data. The quote includes the reboot count, but the sealed data does not reference it, so the TPM will unseal it if the AK is still valid, even if an attacker has rebooted into an untrustworthy state inbetween generating the quote and receiving the sealed response. By creating an ephemeral AK (with the stclear bit set in the attributes), the TPM will not allow it to be persisted and will refuse to reload it when the reboot counter increments.","title":"Why is generating a quote so slow?"},{"location":"attestation/#discrete-tpm-vs-ftpm","text":"The Discrete TPM is potentially a hardware weakpoint; a physically proximate adversary could remove the TPM from a machine and connect it to an untrusted device and then masquarade as the device to which the TPM had been connected. This would also potentially allow them to extract any sealed disk encryption keys, as described on the threat model page , and is one of the advantages of an fTPM inside the Management Engine. A proximate attacker could also interfere with the LPC or i2c bus of a Discrete TPM using something like the TPM Genie , which allow them to both modify the hashes sent to the TPM during PCR extension operations, and read the unsealed secrets when they are returned if the TPM didn't support secret sessions. However, the fTPM is a pure-software application inside the ME and potentially allows an attacker with code execution on the ME to find the sealing secrets that are used to protect the TPM keys in the ME NVRAM, which would allow attacks against the quoting and attestation process.","title":"Discrete TPM vs fTPM?"},{"location":"chain-of-trust/","text":"Chain of Trust Booting a modern x86 CPU is no longer as simple as it used to be. This page attempts to document the entire chain of trust and keys involved in securing the boot process. It is based on reverse engineered and observed behaviour, so it may not be entirely accurate. Hopefully it is still helpful. Keys and certificates Intel's ME public key hash on die Intel's ME public key stored in flash Intel's ucode symmetric key (burned into the CPU?) Intel's ucode public key hash (burned into the CPU?) Intel's ucode public key stored in ucode file in the flash Intel's ACM public key hash (in CPU and updatable in microcode?) Intel's ACM public key in the ACM header OEM Key Manifest Security Version Number (KMSVN, stored in fuses in PCH) OEM root public key hash (OTP fuses in the PCH, delivered from ME to x86) Bootguard Key Manifest (with KMSVN to protect against rollback) signed by OEM public key OEM root public key in the Bootguard Key Manifest in the flash OEM per-model public key stored in Bootguard Key Manifest Bootguard Boot Policy, signed by OEM per-model public key Bootguard region hashes, stored in Bootguard Boot Policy UEFI Platform Key (PK) / Key Exchange Key (KEK) / Database keys (DB) / Revocation Database (DBX) CA root key TPM OEM root certificate TPM OEM intermediate certificate TPM Endorsement Key TPM Attestation Key Linux kernel keyring ME Startup As soon as power is available, the ME boots up from its on-die boot ROM, checks some straps and fuses to determine its configuration, and typically then copies the flash partition table from the ME region of the flash to its on-die SRAM (although ROMB fused chips have limited security). The boot ROM locates the FTPR partition and copies it from the SPI flash into the on-die SRAM. It then checks that the SHA-1 hash of the key stored in the parition manifest matches the one in its on-die ROM and validates the RSA signature on the rest of the partition manifest. The partition table contains hashes of each of the modules in the partition, allowing the modules to be validated after they are copied into the on-die SRAM for execution ( Intel ME Flash File System Explained - Sklyarov et al, BH-EU 2017). x86 ucode and ACM When the ME starts the clocks for the x86 CPU, the on-die microcode fetches the Firmware Interface Table (FIT) pointer at 0xFFFFFFC0 which points to the FIT table somewhere in the SPI flash image. This table is then searched for microcode updates that match the CPU ID. The current microcode copies them from flash in a linear fashion (into L3 cache?) and decrypts with an on-die symmetric AES key ( Chen & Ahn 2014 ), then validates with (on-die?) RSA key. It's likely that these ucode updates also contain the key hashes for the ACM. Next the x86 ucode goes back to the FIT to find the Startup ACM and does an odd copy of it into L3 (looks like multiple hyperthreads are copying 4KB chunks?). The ACM contains an RSA public key; the ucode compares it against either an on-die key (hash?) or one stored in the ucode update and halts the CPU if it does not match. The ucode then checks the signature on the ACM and again halts if it does not match. The Startup ACM is supposed to run entirely out of L3, although there have been bugs ( Bosch & Hudson, 2019 ) that allowed a proximate attacker to use devices like the Spispy to detect accidental cache misses and TOCTOU the firmware. The ACM receives the OEM public key hash and Bootguard Profile from the ME via MSR. (Not certain of the order of operations here). The ACM reads the BootGuard Key Manifest from the SPI flash (pointed to by the FIT and identified by __KEYM__ ) into L3 and hashes the RSA public key stored in it. If it doesn't match the OEM public key hash or if the OEM public key signature on the Key Manifest or if the stored KmSvn isn't right, the ACM takes action based on the Bootguard Profile bits. If it does match, it locates the Bootguard Policy in the FIT (and identified by __ACBP__ ) and copies it into L3. The ACM then computes the hash of the RSA public key in the Policy and compares it to the SHA256 hash stored in the Key Manifest. If that fails to match, or if the RSA signature on the Policy doesn't match, then the ACM again takes action based on the Profile settings. The ACM uses the now validated Bootguard Policy structure to read the Initial Boot Block (IBB) segments into L3, hashing them as they are copied (and hopefully not causing any cache misses). If this computed hash doesn't match the \"IBB Digest\" in the Policy, the ACM takes action based on the Profile settings. UEFI After some parts of the UEFI firmware are hashed and validated by BootGuard, the ACM executes a GETSEC instruction to jump to either the legacy reset vector at 0xFFFFFFF0 or the address in the BootGuard manifest. This is typically in the PEI firmware volume and in the SecCore.efi executable with the VolumeTopFile GUID. At this point the chain of trust is now controlled by the OEM and they are responsible for validating the rest of the firmware. Usually they will jump into the Intel FSP to initialze DRAM (on AMD the PSP has initialized DRAM prior to starting the BIOS, although they have a separate chain of trust entirely). Once DRAM is initialized, the SecCore copies the DXE firmware volumes from flash into RAM and computes their hashes. The major BIOS vendors (IBV) have their own data structures, such as the AMIHash or PhoenixHash, that are used to enumerate the regions to be hashed. This is another common area of TOCTOU attacks against the boot process. (Need to document when UEFI capsule updates are searched and when the PRR are locked to prevent further flash writes) The UEFI firmware stores non-volatile configuration data in the flash as well. These \"nvram variables\" are controlled by the computer owner and begin the chain of trust transition from the OEM to the owner. The SecureBoot variable tells the firmware if it should enable UEFI Secure Boot. If it is set, then the firmware will attempt to enforce the secure boot policy. To do this it has a Platform Key ( PK ), which signs the Key-Exchange-Key ( KEK ), which signs entries in the key database ( db ) as well as key revocation entries ( dbx ). Typically the PK and KEK are OEM keys (I think) and the db is preloaded with Microsoft's key. Linux distributions and tools like grub have paid Microsoft to sign their bootloaders, which allow them to boot on commodity systems with UEFI Secure Boot enabled. It is also possible to replace these keys, and the safeboot project loads an owner controlled key into the PK to ensure that only owner signed code will be booted. However, before the firmware can locate the boot disk, which might be SATA, NVME, USB, or network, it needs to initialize the hardware and possibly load Option ROMs from devices to configure them. These Options ROMs are literally x86 code that is run in ring 0 while the system is still in a very vulnerable state, so it is important that they be signed. Option ROMs have been an easy vulnerability for local attackers for many years (Heasman BH'07, snare BH'12, Hudson 31C3/BH'15). Once the devices have been initialized, UEFI transitions to the Boot Device Selector phase ( BDS ), which uses the nvram variables BootNext , Boot0000 , Boot0001 , etc to determine which boot loader to use. The BDS also calls bs->ExitBootServices() to tell the firmware that the OS is about to start, which locks some of the firmware variables from further updates. Linux (To be added: shim protocol?) Linux has a kernel key ring that is loaded at boot time with the UEFI keys as well as a compile-time key. It validates kernel modules with this key. (To be written) TPM (To be written)","title":"Chain of Trust"},{"location":"chain-of-trust/#chain-of-trust","text":"Booting a modern x86 CPU is no longer as simple as it used to be. This page attempts to document the entire chain of trust and keys involved in securing the boot process. It is based on reverse engineered and observed behaviour, so it may not be entirely accurate. Hopefully it is still helpful.","title":"Chain of Trust"},{"location":"chain-of-trust/#keys-and-certificates","text":"Intel's ME public key hash on die Intel's ME public key stored in flash Intel's ucode symmetric key (burned into the CPU?) Intel's ucode public key hash (burned into the CPU?) Intel's ucode public key stored in ucode file in the flash Intel's ACM public key hash (in CPU and updatable in microcode?) Intel's ACM public key in the ACM header OEM Key Manifest Security Version Number (KMSVN, stored in fuses in PCH) OEM root public key hash (OTP fuses in the PCH, delivered from ME to x86) Bootguard Key Manifest (with KMSVN to protect against rollback) signed by OEM public key OEM root public key in the Bootguard Key Manifest in the flash OEM per-model public key stored in Bootguard Key Manifest Bootguard Boot Policy, signed by OEM per-model public key Bootguard region hashes, stored in Bootguard Boot Policy UEFI Platform Key (PK) / Key Exchange Key (KEK) / Database keys (DB) / Revocation Database (DBX) CA root key TPM OEM root certificate TPM OEM intermediate certificate TPM Endorsement Key TPM Attestation Key Linux kernel keyring","title":"Keys and certificates"},{"location":"chain-of-trust/#me-startup","text":"As soon as power is available, the ME boots up from its on-die boot ROM, checks some straps and fuses to determine its configuration, and typically then copies the flash partition table from the ME region of the flash to its on-die SRAM (although ROMB fused chips have limited security). The boot ROM locates the FTPR partition and copies it from the SPI flash into the on-die SRAM. It then checks that the SHA-1 hash of the key stored in the parition manifest matches the one in its on-die ROM and validates the RSA signature on the rest of the partition manifest. The partition table contains hashes of each of the modules in the partition, allowing the modules to be validated after they are copied into the on-die SRAM for execution ( Intel ME Flash File System Explained - Sklyarov et al, BH-EU 2017).","title":"ME Startup"},{"location":"chain-of-trust/#x86-ucode-and-acm","text":"When the ME starts the clocks for the x86 CPU, the on-die microcode fetches the Firmware Interface Table (FIT) pointer at 0xFFFFFFC0 which points to the FIT table somewhere in the SPI flash image. This table is then searched for microcode updates that match the CPU ID. The current microcode copies them from flash in a linear fashion (into L3 cache?) and decrypts with an on-die symmetric AES key ( Chen & Ahn 2014 ), then validates with (on-die?) RSA key. It's likely that these ucode updates also contain the key hashes for the ACM. Next the x86 ucode goes back to the FIT to find the Startup ACM and does an odd copy of it into L3 (looks like multiple hyperthreads are copying 4KB chunks?). The ACM contains an RSA public key; the ucode compares it against either an on-die key (hash?) or one stored in the ucode update and halts the CPU if it does not match. The ucode then checks the signature on the ACM and again halts if it does not match. The Startup ACM is supposed to run entirely out of L3, although there have been bugs ( Bosch & Hudson, 2019 ) that allowed a proximate attacker to use devices like the Spispy to detect accidental cache misses and TOCTOU the firmware. The ACM receives the OEM public key hash and Bootguard Profile from the ME via MSR. (Not certain of the order of operations here). The ACM reads the BootGuard Key Manifest from the SPI flash (pointed to by the FIT and identified by __KEYM__ ) into L3 and hashes the RSA public key stored in it. If it doesn't match the OEM public key hash or if the OEM public key signature on the Key Manifest or if the stored KmSvn isn't right, the ACM takes action based on the Bootguard Profile bits. If it does match, it locates the Bootguard Policy in the FIT (and identified by __ACBP__ ) and copies it into L3. The ACM then computes the hash of the RSA public key in the Policy and compares it to the SHA256 hash stored in the Key Manifest. If that fails to match, or if the RSA signature on the Policy doesn't match, then the ACM again takes action based on the Profile settings. The ACM uses the now validated Bootguard Policy structure to read the Initial Boot Block (IBB) segments into L3, hashing them as they are copied (and hopefully not causing any cache misses). If this computed hash doesn't match the \"IBB Digest\" in the Policy, the ACM takes action based on the Profile settings.","title":"x86 ucode and ACM"},{"location":"chain-of-trust/#uefi","text":"After some parts of the UEFI firmware are hashed and validated by BootGuard, the ACM executes a GETSEC instruction to jump to either the legacy reset vector at 0xFFFFFFF0 or the address in the BootGuard manifest. This is typically in the PEI firmware volume and in the SecCore.efi executable with the VolumeTopFile GUID. At this point the chain of trust is now controlled by the OEM and they are responsible for validating the rest of the firmware. Usually they will jump into the Intel FSP to initialze DRAM (on AMD the PSP has initialized DRAM prior to starting the BIOS, although they have a separate chain of trust entirely). Once DRAM is initialized, the SecCore copies the DXE firmware volumes from flash into RAM and computes their hashes. The major BIOS vendors (IBV) have their own data structures, such as the AMIHash or PhoenixHash, that are used to enumerate the regions to be hashed. This is another common area of TOCTOU attacks against the boot process. (Need to document when UEFI capsule updates are searched and when the PRR are locked to prevent further flash writes) The UEFI firmware stores non-volatile configuration data in the flash as well. These \"nvram variables\" are controlled by the computer owner and begin the chain of trust transition from the OEM to the owner. The SecureBoot variable tells the firmware if it should enable UEFI Secure Boot. If it is set, then the firmware will attempt to enforce the secure boot policy. To do this it has a Platform Key ( PK ), which signs the Key-Exchange-Key ( KEK ), which signs entries in the key database ( db ) as well as key revocation entries ( dbx ). Typically the PK and KEK are OEM keys (I think) and the db is preloaded with Microsoft's key. Linux distributions and tools like grub have paid Microsoft to sign their bootloaders, which allow them to boot on commodity systems with UEFI Secure Boot enabled. It is also possible to replace these keys, and the safeboot project loads an owner controlled key into the PK to ensure that only owner signed code will be booted. However, before the firmware can locate the boot disk, which might be SATA, NVME, USB, or network, it needs to initialize the hardware and possibly load Option ROMs from devices to configure them. These Options ROMs are literally x86 code that is run in ring 0 while the system is still in a very vulnerable state, so it is important that they be signed. Option ROMs have been an easy vulnerability for local attackers for many years (Heasman BH'07, snare BH'12, Hudson 31C3/BH'15). Once the devices have been initialized, UEFI transitions to the Boot Device Selector phase ( BDS ), which uses the nvram variables BootNext , Boot0000 , Boot0001 , etc to determine which boot loader to use. The BDS also calls bs->ExitBootServices() to tell the firmware that the OS is about to start, which locks some of the firmware variables from further updates.","title":"UEFI"},{"location":"chain-of-trust/#linux","text":"(To be added: shim protocol?) Linux has a kernel key ring that is loaded at boot time with the UEFI keys as well as a compile-time key. It validates kernel modules with this key. (To be written)","title":"Linux"},{"location":"chain-of-trust/#tpm","text":"(To be written)","title":"TPM"},{"location":"faq/","text":"Frequently Asked Questions What is the threat model? safeboot intends to protect the integrity of the boot process and runtime integrity of the system against adversaries with external physical access to the device, as well as limited internal physical access. The assumption is that the attacker can get code execution on the device as the user and as root, but does not have access to the signing keys or the disk encryption key. The goal is to prevent the attacker from exfiltrating data from the device or making persistent changes to the system configuration. More details are in the threat model page . How is this better than normal UEFI Secure Boot? safeboot is not a replacement for UEFI SecureBoot - the two work together to improve the security of the system. SecureBoot ensures that the boot firmware is measured into the TPM and validates the signatures on the Linux kernel and initrd, and safeboot adds additional integrity protections beyond that. The default UEFI Secure Boot configuration is sufficient for Microsoft's needs since they are the only signing authority for their runtime, while Linux computer owners frequently want to compile their own kernel or runtime. The compromise solution developed by Linux distributions has Microsoft sign a \"shim\" bootloader that has its own key management. Since most distributions have their keys enrolled in the shim, systems that have Secure Boot enabled will boot the distribution's ISOs, which might not be desirable since it potentially gives an adversary runtime access to unencrypted parts of the system. A larger problem is that by default only the Linux kernel is signed, not the command line parameters or initrd. While the grub bootloader can enable a password to protect against casual changes to the kernel parameters, the grub.cfg configuration is not typically signed. This means that potentially a local attacker can modify it on disk to launch the kernel with init=/bin/sh to drop into a shell, or an attacker with root access can add trojan'ed binaries to the initrd to gain persistence. By replacing the Platform Key and removing grub , only Linux kernel and initrd images signed by the computer owner will boot. Far more details on how safeboot extends UEFI SecureBoot are on the threat model page . Does safeboot have a BootHole? BootHole ( CVE-2020-10713 ), is a vulnerability found and described by Eclypsium ) in grub 's configuration file parsing which allows arbitrary code execution in grub even when Secure Boot is enabled. Kelly Shortridge has a good writeup by at capsule8 that explains how this threat could be leveraged by an attacker and the difficulties in doing so in a general case, although an attacker with physical access is able to write to the internal disk and could launch this attack. Since these sorts of physical attacks are included in the safeboot threat model , it is worth considering. However, a system using safeboot is not vulnerable to CVE-2020-10713 since grub is not used at all and will not be run even if it is present on the disk. During the safeboot installation process, the system owner replaces the UEFI Platform Key with their own , which prevents the Microsoft signed shim used by grub from being loaded, and they then create efibootmgr entries for linux and recovery that are signed with their (hardware protected) key. Assuming there are not vulnerabilities in the system's UEFI firmware or CPU vendor's BootGuard (which may not be the best assumption...), the safeboot configuration should ensure that only signed kernel, initrd, and command lines will be booted by the system. This static chain of trust helps prevent attacks on grub like BootHole, or other ones that modify on-disk data, from being able to gain persistence or code execution. One caveat to the protection provided by the UEFI Secure Boot Platform Keys is that the UEFI NVRAM configuration data is stored in the SPI flash and is also subject to modifications by a physically proximate attacker with internal access to the hardware. However, if the attacker uses a flash programmer to change the Platform Keys in the flash, the TPM measurements of the Setup variable will be different and the TPM should refuse to unseal the disk encryption key since the PCR values will not match the sealed ones. The adversary might try to roll back to an vulnerable version of the kernel and the earlier signed PCRs, but the TPM will refuse to unseal since monotonic counter value will not match the signed one. An adversary might create a fake PIN entry screen to try to harvest the unsealing PIN or the recovery key, although in any of these cases, the TPM TOTP six-digit authenicator value will not be correct since the TPM will not unseal it with modified firmware. Additionally the system should fail remote attestation if it attempts to connect to a server that validates the TPM quote, improving platform resiliency even when attackers do gain persistence. How does safeboot compare to coreboot? coreboot is entirely free software and can provide far better control of the boot process, although it is not supported on as many modern platforms as UEFI SecureBoot and requires reprogramming the SPI flash on the device. If you have a machine that supports both coreboot and Bootguard, then you're probably better off running it instead. However, be prepared to spend quite a bit of quality time with your SPI flash programmer to get it working... Once coreboot or UEFI hand off to the Linux kernel, the TPM unsealing of the disk encryption key, the dmverity protections on the root filesystem and the lockdown patches work the same. Does safeboot work with AMD cpus? It has only been tested on the Intel systems with Bootguard. The UEFI platform keys and the rest of the lock down should work with AMD, although AMD's hardware secured boot process hasn't been reviewed as extensively as Intel's ME and Bootguard. For an indepth analysis of the AMD Platform Support Processor (PSP) and SEV, Buhren, Eichner and Werling's 35c3 presentation is the most detailed look so far. Does safeboot work with Qubes or Xen? Qubes, a reasonably secure OS, uses the Xen hypervisor to separate device drivers and applications into separate virtual machines so that an exploit against an individual component doesn't necessarily compromise the entire machine. Unfortunately Xen's EFI support is not commonly used, and as a result running Qubes typically requires Legacy BIOS and turning off Secure Boot. Adding Secure Boot support to Xen is possible with some patches ( safeboot-issue #21 ), although it is a work in progress. There are other factors involved in configuring Qubes to use dm-verity and TPM sealed secrets that have not been addressed yet, as well as an open qubes-issue on distribution signing keys . What causes the TPM unsealing to fail? The TPM will only unseal the disk encryption key if: The policy is signed by the UEFI platform key. The PCRs in $PCRS match the ones computed by the TPM, which typically include the firmware, UEFI setup variable, UEFI key database, and the PE hash of the kernel + initrd. The boot mode PCR in $BOOTMODE_PCR matches the sha256 hash of the safeboot.mode= kernel command line parameter and has not been extended post-boot. The TPM monotonic counter in $TPM_NV_VERSION matches the one in the policy. The user PIN matches the on used to seal the data. These requirements are violated by several different attacks, although they can also fail if a new kernel is installed with safeboot linux-sign and safeboot pcrs-sign was not successful. Typically kernel updates can be handled seamlessly since the PCR4 value can be predicted from the PE hash of the new kernel and initrd. The PCRs will also be different when the system has had a firmware update from fwupd (usually measured into PCR0), or if the UEFI configuration is changed by the administrator (usually measured into PCR1 and PCR5). In both of these cases it is hard to predict what the resulting PCR values will be, so it is typically necessary to reboot into the recovery target to extend the PCRs with the new measurements and then update the PCR policy with the new values by running safeboot pcrs-sign . Some vendors publish the new PCR0 values, and it might be possible to predict it by evaluating the TPM event log, but it is not guaranteed. For a fleet of identical systems, however, it is usually possible to do this upgrade on one offline machine and then distribute the signed kernel along with the signed PCR policy to the other machines. This requires some additional work to make practical, since the TPM counters are not synchronized. How is safeboot's SIP related to macOS SIP? safeboot 's System Integrity Protection (SIP) is inspired by the read-only filesystems of macOS SIP . Like macOS, writing to the protected filesystems requires rebooting with a special kernel command line parameter (in this case tpm.mode=recovery ) to enable write access. Unlike macOS, safeboot SIP can not unseal the disk encryption keys automatically from the TPM since the boot mode is part of the PCR measurements, so knowledge of the disk recovery password is required. This prevents a local adversary who escalates to root from being able to disable SIP and reboot into a writable filesystem to try to gain persistence. safeboot's SIP is also inspired by the Android Verified Boot that protects Android's /system partition. Like Android, safeboot SIP provides cryptographic protection against an adversary who gains write access to the filesystem since entire filesystem is protected by the dmverity merkle tree of hashes. The root hash is signed by the system owner as part of exiting recovery mode, and this root hash is passed into the kernel on the command line. The kernel command line is part of the cryptographic chain of trust from the CPU boostrap through the Bootguard ACM, into the UEFI firmware, and all the way to the Linux kernel and initrd. This is potentially even stronger protection than macOS SIP since it provides protection even against an adversary with physical access, the root password and the disk recovery key. They can't sign the root hash without the hardware token, and if they change the signing keys in the firmare, then the TPM will no longer unseal the disk encryption key. They could re-seal the key with the new PCRs from their fake platform key, but the system would then fail both the TPM TOTP local attestation as well as the remote attestation when it tried to prove to an external system that it was in a trusted state. How do I write to the root filesystem? With SIP enabled it is not possible to modify the root filesystem. You must reboot into recovery mode with safeboot recovery-reboot and decrypt the disk with the recovery password. Once decrypted, you can run safeboot remount to unlock the raw device and remount it rw . After making modifications, it is necessary to sign the new root hashes with safeboot linux-sign . How do I switch to a new signing key? There is probably a way to sign a new PK with the old PK, but I haven't figured it out... Instead here are the steps: Put the UEFI SecureBoot firmware back in Setup Mode Boot into the recovery kernel safeboot remount to get write-access to the disk safeboot key-init or safeboot yubikey-init to build a new key. Answer \" y \" to overwrite the existing one in /etc/safeboot/cert.pem . safeboot uefi-sign-keys to upload it into the firmware safeboot recover-sign safeboot linux-sign , which should re-generate the dmverity hashes Reboot into the normal kernel safeboot luks-seal to measure the new PCRs and normal kernel into the TPM What happens if I lose the signing key? The best solution is to authenticate with the supervisor password to the UEFI Setup, re-enter SecureBoot setup mode and clear the key database, then boot into recovery mode and follow the instructions for switching to a new signing key. If you don't have the UEFI Supervisor password, well, then you're in trouble. Is it possible to reset the UEFI or BIOS password? On modern Thinkpads the UEFI password is in the EC, not in the SPI flash. Lenovo does a mainboard swap to reset it; you could find a EC bypass (Matrosov 2019) or perhaps a Bootguard bypass (Bosch & Hudson, 2019) to get into Setup in that case. Matrosov's 2019 BlackHat Talk is a deep dive into the Lenovo EC and why it is not as much of a protection boundary as some vendors think it is. Does it work on the Thinkpad 701c? Unfortunately the wonderful butterfly keyboard Thinkpad predates UEFI by a few years, so it does not have a very secure boot process. The X1 Carbon is a much nicer replacement in nearly every way, other than missing the amazing sliding keyboard mechanism. ??? Please file an issue! Or submit a pull-request!","title":"Frequently Asked Questions"},{"location":"faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"faq/#what-is-the-threat-model","text":"safeboot intends to protect the integrity of the boot process and runtime integrity of the system against adversaries with external physical access to the device, as well as limited internal physical access. The assumption is that the attacker can get code execution on the device as the user and as root, but does not have access to the signing keys or the disk encryption key. The goal is to prevent the attacker from exfiltrating data from the device or making persistent changes to the system configuration. More details are in the threat model page .","title":"What is the threat model?"},{"location":"faq/#how-is-this-better-than-normal-uefi-secure-boot","text":"safeboot is not a replacement for UEFI SecureBoot - the two work together to improve the security of the system. SecureBoot ensures that the boot firmware is measured into the TPM and validates the signatures on the Linux kernel and initrd, and safeboot adds additional integrity protections beyond that. The default UEFI Secure Boot configuration is sufficient for Microsoft's needs since they are the only signing authority for their runtime, while Linux computer owners frequently want to compile their own kernel or runtime. The compromise solution developed by Linux distributions has Microsoft sign a \"shim\" bootloader that has its own key management. Since most distributions have their keys enrolled in the shim, systems that have Secure Boot enabled will boot the distribution's ISOs, which might not be desirable since it potentially gives an adversary runtime access to unencrypted parts of the system. A larger problem is that by default only the Linux kernel is signed, not the command line parameters or initrd. While the grub bootloader can enable a password to protect against casual changes to the kernel parameters, the grub.cfg configuration is not typically signed. This means that potentially a local attacker can modify it on disk to launch the kernel with init=/bin/sh to drop into a shell, or an attacker with root access can add trojan'ed binaries to the initrd to gain persistence. By replacing the Platform Key and removing grub , only Linux kernel and initrd images signed by the computer owner will boot. Far more details on how safeboot extends UEFI SecureBoot are on the threat model page .","title":"How is this better than normal UEFI Secure Boot?"},{"location":"faq/#does-safeboot-have-a-boothole","text":"BootHole ( CVE-2020-10713 ), is a vulnerability found and described by Eclypsium ) in grub 's configuration file parsing which allows arbitrary code execution in grub even when Secure Boot is enabled. Kelly Shortridge has a good writeup by at capsule8 that explains how this threat could be leveraged by an attacker and the difficulties in doing so in a general case, although an attacker with physical access is able to write to the internal disk and could launch this attack. Since these sorts of physical attacks are included in the safeboot threat model , it is worth considering. However, a system using safeboot is not vulnerable to CVE-2020-10713 since grub is not used at all and will not be run even if it is present on the disk. During the safeboot installation process, the system owner replaces the UEFI Platform Key with their own , which prevents the Microsoft signed shim used by grub from being loaded, and they then create efibootmgr entries for linux and recovery that are signed with their (hardware protected) key. Assuming there are not vulnerabilities in the system's UEFI firmware or CPU vendor's BootGuard (which may not be the best assumption...), the safeboot configuration should ensure that only signed kernel, initrd, and command lines will be booted by the system. This static chain of trust helps prevent attacks on grub like BootHole, or other ones that modify on-disk data, from being able to gain persistence or code execution. One caveat to the protection provided by the UEFI Secure Boot Platform Keys is that the UEFI NVRAM configuration data is stored in the SPI flash and is also subject to modifications by a physically proximate attacker with internal access to the hardware. However, if the attacker uses a flash programmer to change the Platform Keys in the flash, the TPM measurements of the Setup variable will be different and the TPM should refuse to unseal the disk encryption key since the PCR values will not match the sealed ones. The adversary might try to roll back to an vulnerable version of the kernel and the earlier signed PCRs, but the TPM will refuse to unseal since monotonic counter value will not match the signed one. An adversary might create a fake PIN entry screen to try to harvest the unsealing PIN or the recovery key, although in any of these cases, the TPM TOTP six-digit authenicator value will not be correct since the TPM will not unseal it with modified firmware. Additionally the system should fail remote attestation if it attempts to connect to a server that validates the TPM quote, improving platform resiliency even when attackers do gain persistence.","title":"Does safeboot have a BootHole?"},{"location":"faq/#how-does-safeboot-compare-to-coreboot","text":"coreboot is entirely free software and can provide far better control of the boot process, although it is not supported on as many modern platforms as UEFI SecureBoot and requires reprogramming the SPI flash on the device. If you have a machine that supports both coreboot and Bootguard, then you're probably better off running it instead. However, be prepared to spend quite a bit of quality time with your SPI flash programmer to get it working... Once coreboot or UEFI hand off to the Linux kernel, the TPM unsealing of the disk encryption key, the dmverity protections on the root filesystem and the lockdown patches work the same.","title":"How does safeboot compare to coreboot?"},{"location":"faq/#does-safeboot-work-with-amd-cpus","text":"It has only been tested on the Intel systems with Bootguard. The UEFI platform keys and the rest of the lock down should work with AMD, although AMD's hardware secured boot process hasn't been reviewed as extensively as Intel's ME and Bootguard. For an indepth analysis of the AMD Platform Support Processor (PSP) and SEV, Buhren, Eichner and Werling's 35c3 presentation is the most detailed look so far.","title":"Does safeboot work with AMD cpus?"},{"location":"faq/#does-safeboot-work-with-qubes-or-xen","text":"Qubes, a reasonably secure OS, uses the Xen hypervisor to separate device drivers and applications into separate virtual machines so that an exploit against an individual component doesn't necessarily compromise the entire machine. Unfortunately Xen's EFI support is not commonly used, and as a result running Qubes typically requires Legacy BIOS and turning off Secure Boot. Adding Secure Boot support to Xen is possible with some patches ( safeboot-issue #21 ), although it is a work in progress. There are other factors involved in configuring Qubes to use dm-verity and TPM sealed secrets that have not been addressed yet, as well as an open qubes-issue on distribution signing keys .","title":"Does safeboot work with Qubes or Xen?"},{"location":"faq/#what-causes-the-tpm-unsealing-to-fail","text":"The TPM will only unseal the disk encryption key if: The policy is signed by the UEFI platform key. The PCRs in $PCRS match the ones computed by the TPM, which typically include the firmware, UEFI setup variable, UEFI key database, and the PE hash of the kernel + initrd. The boot mode PCR in $BOOTMODE_PCR matches the sha256 hash of the safeboot.mode= kernel command line parameter and has not been extended post-boot. The TPM monotonic counter in $TPM_NV_VERSION matches the one in the policy. The user PIN matches the on used to seal the data. These requirements are violated by several different attacks, although they can also fail if a new kernel is installed with safeboot linux-sign and safeboot pcrs-sign was not successful. Typically kernel updates can be handled seamlessly since the PCR4 value can be predicted from the PE hash of the new kernel and initrd. The PCRs will also be different when the system has had a firmware update from fwupd (usually measured into PCR0), or if the UEFI configuration is changed by the administrator (usually measured into PCR1 and PCR5). In both of these cases it is hard to predict what the resulting PCR values will be, so it is typically necessary to reboot into the recovery target to extend the PCRs with the new measurements and then update the PCR policy with the new values by running safeboot pcrs-sign . Some vendors publish the new PCR0 values, and it might be possible to predict it by evaluating the TPM event log, but it is not guaranteed. For a fleet of identical systems, however, it is usually possible to do this upgrade on one offline machine and then distribute the signed kernel along with the signed PCR policy to the other machines. This requires some additional work to make practical, since the TPM counters are not synchronized.","title":"What causes the TPM unsealing to fail?"},{"location":"faq/#how-is-safeboots-sip-related-to-macos-sip","text":"safeboot 's System Integrity Protection (SIP) is inspired by the read-only filesystems of macOS SIP . Like macOS, writing to the protected filesystems requires rebooting with a special kernel command line parameter (in this case tpm.mode=recovery ) to enable write access. Unlike macOS, safeboot SIP can not unseal the disk encryption keys automatically from the TPM since the boot mode is part of the PCR measurements, so knowledge of the disk recovery password is required. This prevents a local adversary who escalates to root from being able to disable SIP and reboot into a writable filesystem to try to gain persistence. safeboot's SIP is also inspired by the Android Verified Boot that protects Android's /system partition. Like Android, safeboot SIP provides cryptographic protection against an adversary who gains write access to the filesystem since entire filesystem is protected by the dmverity merkle tree of hashes. The root hash is signed by the system owner as part of exiting recovery mode, and this root hash is passed into the kernel on the command line. The kernel command line is part of the cryptographic chain of trust from the CPU boostrap through the Bootguard ACM, into the UEFI firmware, and all the way to the Linux kernel and initrd. This is potentially even stronger protection than macOS SIP since it provides protection even against an adversary with physical access, the root password and the disk recovery key. They can't sign the root hash without the hardware token, and if they change the signing keys in the firmare, then the TPM will no longer unseal the disk encryption key. They could re-seal the key with the new PCRs from their fake platform key, but the system would then fail both the TPM TOTP local attestation as well as the remote attestation when it tried to prove to an external system that it was in a trusted state.","title":"How is safeboot's SIP related to macOS SIP?"},{"location":"faq/#how-do-i-write-to-the-root-filesystem","text":"With SIP enabled it is not possible to modify the root filesystem. You must reboot into recovery mode with safeboot recovery-reboot and decrypt the disk with the recovery password. Once decrypted, you can run safeboot remount to unlock the raw device and remount it rw . After making modifications, it is necessary to sign the new root hashes with safeboot linux-sign .","title":"How do I write to the root filesystem?"},{"location":"faq/#how-do-i-switch-to-a-new-signing-key","text":"There is probably a way to sign a new PK with the old PK, but I haven't figured it out... Instead here are the steps: Put the UEFI SecureBoot firmware back in Setup Mode Boot into the recovery kernel safeboot remount to get write-access to the disk safeboot key-init or safeboot yubikey-init to build a new key. Answer \" y \" to overwrite the existing one in /etc/safeboot/cert.pem . safeboot uefi-sign-keys to upload it into the firmware safeboot recover-sign safeboot linux-sign , which should re-generate the dmverity hashes Reboot into the normal kernel safeboot luks-seal to measure the new PCRs and normal kernel into the TPM","title":"How do I switch to a new signing key?"},{"location":"faq/#what-happens-if-i-lose-the-signing-key","text":"The best solution is to authenticate with the supervisor password to the UEFI Setup, re-enter SecureBoot setup mode and clear the key database, then boot into recovery mode and follow the instructions for switching to a new signing key. If you don't have the UEFI Supervisor password, well, then you're in trouble.","title":"What happens if I lose the signing key?"},{"location":"faq/#is-it-possible-to-reset-the-uefi-or-bios-password","text":"On modern Thinkpads the UEFI password is in the EC, not in the SPI flash. Lenovo does a mainboard swap to reset it; you could find a EC bypass (Matrosov 2019) or perhaps a Bootguard bypass (Bosch & Hudson, 2019) to get into Setup in that case. Matrosov's 2019 BlackHat Talk is a deep dive into the Lenovo EC and why it is not as much of a protection boundary as some vendors think it is.","title":"Is it possible to reset the UEFI or BIOS password?"},{"location":"faq/#does-it-work-on-the-thinkpad-701c","text":"Unfortunately the wonderful butterfly keyboard Thinkpad predates UEFI by a few years, so it does not have a very secure boot process. The X1 Carbon is a much nicer replacement in nearly every way, other than missing the amazing sliding keyboard mechanism.","title":"Does it work on the Thinkpad 701c?"},{"location":"faq/#_1","text":"Please file an issue! Or submit a pull-request!","title":"???"},{"location":"install/","text":"Danger Be careful! When following these instructions: it is possible to lock yourself out from your own machine if you forget some of the passwords. It is best to try this on a non-production system until you're certain that you understand how to use the recovery mode to fix bad kernel signatures or hashes. This guide was written for a Thinkpad X1 Carbon Gen 6 running Ubuntu 20.04. Unfortunately there has been churn in the tpm2 tools, so the Debian package does not work on 18.04. The outline for configuring safeboot requires some knowledge of the command line and familiarity with running commands as root with sudo . Releases for the the safeboot Debian package are in safeboot/releases . tl;dr Set UEFI SecureBoot setup mode Install Ubuntu 20.04, configure encrypted LVM partition Resizing '/' to 8GB during the install if you want to enable SIP wget https://github.com/osresearch/safeboot/releases/download/release-0.7/safeboot_0.7_amd64.deb sudo apt install safeboot_0.7_amd64.deb sudo update-initramfs -u sudo safeboot yubikey-init /CN=foo/ # or safeboot key-init if you don't have a token sudo safeboot uefi-sign-keys sudo safeboot recovery-sign sudo safeboot recovery-reboot # Should reboot into the recovery image. Login as usual. sudo safeboot luks-seal sudo update-initramfs -u sudo safeboot sip-init # if you want to enable SIP mode sudo safeboot recovery-sign sudo safeboot recovery-reboot # Should reboot into the recovery image again, with `/` mounted read-only. sudo safeboot linux-sign sudo reboot # Reboot one more time, now into dmverity protect Linux image... sudo safeboot luks-seal sudo reboot After this final reboot, the UEFI SecureBoot database will have the public signing keys, the UEFI boot manager will have entries for linux (which boots with a read-only dmverity protected root filesystem) and recovery (which boots with a root filesystem that can be remounted read-write), TPM should contain the disk encryption secret sealed to the linux boot mode, and now the disk should unlock automatically as long as no one tampers with the device. For more details as to how this all works, read on... Initial Setup This is done once when the system is being setup to use Safe Boot mode. Note that the hardware token and key signing portions can be done offline on a separate disconnected machine and then signed keys copied to the machine. UEFI firmware configuration The goal of these configuration changes are to remove several of the easy attacks such as booting from external disks, modifying kernel or initrd on disk, changing kernel command line parameters, as well as some of the more esoteric ones like DMA attacks against the Thunderbolt ports during the boot process. SecureBoot: Enter setup mode, erase keys Supervisor password (do not lose it! it is very difficult to bypass) Tamper switches: require supervisor password Thunderbolt 3: Disabled TPM: Enabled UEFI Secure Boot signing keys UEFI Secure Boot settings that the system will only run bootloaders that are signed by keys in the SPI flash. By default these keys are the OEM and Microsoft, and Microsoft will sign anyone else's key for $99, so it is important to replace these keys with ones under control of the computer owner. There is typically a signed \"shim\" that transfers control to the unsigned grub bootloader and kernel, which is problematic for security. A safer way to boot is to package the kernel, initrd and command line into a single EFI executable that is signed by the computer owner's key. This also reduces the attack surface by removing grub and the overly complicated config files, as well as speeds up the boot process a little bit. The owner key can be generated by openssl and stored offline, although using a hardware token like a yubikey greatly enhances the security of the system since even with root access an attacker can't gain persistence in the / or in the kernel. OpenSSL key generation First step is to generate a new key that will be used for UEFI SecureBoot: sudo safeboot key-init /CN=foo/OU=bar/O=example.com/ The key-init subcommand will generate a password protected RSA2048 key and store it in /etc/safeboot/ along with the public certificate. The password provided here will be required to sign new kernel images and initrds, so don't lose it! TODO: What is the purpose of the x509 subject? Yubikey key generation Note Skip this if you have already initialized your hardware token and enrolled your keys in the UEFI SecureBoot database. Running it again will erase the keys from your hardware token. First step is to generate a new key that will be used for UEFI SecureBoot: sudo safeboot yubikey-init /CN=foo/OU=bar/O=example.com/ The yubikey-init subcommand will do several steps: Use ykpersonalize to enable CCID mode. (TODO) Generate a new private key inside the Yubikey and export the public key Self-sign the public key to generate a new x509 certificate Reimport the certificate into the Yubikey so that UEFI variables and images can be signed with the hardware token. The public certificate is stored in /etc/safeboot/cert.pem . The private key never leaves the hardware token so it is much more difficult for an adversary to clone. Enrolling UEFI Platform Keys Replacing the UEFI Platform Key with the generated x509 cert requires that the UEFI SecureBoot firmware be put into \" Setup mode \". On the Thinkpads, select Reset to Setup Mode and Clear All Secure Boot Keys , then boot into Linux. To load the public key from /etc/safeboot/cert.pem into the UEFI secure boot key database: sudo safeboot uefi-sign-keys Once the key has been generated, the x509 certificate needs to be reformatted to be added to the UEFI Secure Boot platform key ( PK ), Key-Exchange Key ( KEK ) and as a key database entry ( db ). Each of these updates needs to be signed with the Platform Key; in the case of the PK it is self-signed. The safeboot uefi-sign-keys subcommand will: Generate the three EFI public key variables updates (UEFI platform key ( PK ), key-exchange key ( KEK ) and database ( db )) Sign the EFI variables with the Yubikey or OpenSSL key (will require a PIN authentication for each variable) Store the signed public certificates into the firmware. Danger Before you reboot! If you have not signed the kernel and initrd as described above, the system will not boot and you will have to disable UEFI Secure Boot to get back into the machine. Signed Linux recovery kernel Warning If you don't have a recovery entry in the EFI boot manager on the disk, you would need to have a USB drive signed with a key in the UEFI db to recover from errors. The next step is to use the Yubikey or OpenSSL key to sign and install a recovery kernel, which will be able to read/write mount the root filesystem, and does not have TPM sealing keys, so it will always require a recovery password to decrypt the disk. sudo safeboot recovery-sign This command will: Add UEFI boot menu item for recovery kernel Create a directory for it in the EFI System Partition (\"ESP\") Merge the vmlinux, initrd and command line into a single EFI executable Sign the merged EFI executable Typically you will not have to redo this command since the normal kernel will be hashed and signed during updates. The one exception is that once SIP mode is enabled you will have to resign the recovery image as well to ensure that it doesn't accidentally write to the / file system and corrupt the hashes. TPM Configuration The commands to seal the LUKS disk encryption key into the TPM, rebuild the initrd, sign the kernel/initrd, and update the expected PCR values are: sudo safeboot luks-seal sudo safeboot linux-sign sudo safeboot pcrs-sign You only need to run safeboot luks-seal the very first time; the sealed secret is included in the initrd image (stored in /etc/safeboot/sealed.secret ). When a new kernel or initrd is built, the platform key is used to sign both the kernel+initrd unified image, as well as the PCRs that go with it. The luks-seal subcommand will: Prompt for a decryption PIN, unless SEAL_PIN=0 in /etc/safeboot/local.conf Create a new disk encryption key with random data Add new key slot to disk with new key (will require the recovery password) Create a TPM policy that requires the PCRs defined in $PCRS to match a signed block Seal the disk encryption key with that policy and store it in /etc/safeboot/sealed.secret Add initramfs building hooks to unseal the secret Modify /etc/crypttab entry to call unlock script if necessary The Trusted Platform Module serves two purposes in securing the process: it helps validate that the firmware and boot configuration is unchanged, and it streamlines the boot process by providing the key for encrypted disks. On modern systems Boot Guard ensures that the initial boot block is measured into the TPM, so a local attacker shouldn't be able to modify the SPI flash contents to bypass the measurements, or to add their own keys to the UEFI key database. (Subject to various CVE's and TOCTOUs, etc) Note The TPM PCRs are somewhat fragile; they include hashes of the ROM images, the EFI executables that have been run along the boot path, etc. For example, entering the UEFI Setup menu will cause different measurements, so the TPM will not automatically unseal on the same boot that the user has entered the setup application. For normal operation only a direct boot into the unified kernel+initrd will automatically decrypt. When a new kernel is installed or the initrd needs to be updated, it is only necessary to sign the kernel and PCRs. The sealed LUKS key is no longer changed and the recovery password is not required. sudo safeboot linux-sign sudo safeboot pcrs-sign System Integrity Protection mode Note The \"SIP\" mode is optional and ensures that even an attacker with root priviledges can't make persistent changes to the contents of the root filesystem. It uses the same dmverity as Android's verified boot mode . The root of the dm-verity Merkle-tree is passed to the kernel as part of the signed command line, ensuring that an attacker can't change anything on the filesystem without access to the signing key. Any modifications to the filesystem will be detected when the modified blocks are read, allowing the system to enter recovery mode to protect its data. RO and RW Partition setup Resizing the root filesystem is necessary so that it can be made read-only, as well as to make space for /home and /var as separate writable mounts, and also so that dmverity hash computation doesn't take forever. The partition resize to prepare the system for SIP mode must be done from the recovery shell, since the root file system can't be mounted while it is being modified. Warning There is a high risk of data loss if these commands are mistyped or if the resize2fs fails. Either run this on a machine that doesn't have important data, or be certain that you have a good backup. In the recovery shell, run these commands to decrypt the root disk, make sure it is clena, resize the filesystem, and then resize the logical volume. No need for sudo , since the recovery shell is always root. crypt_unlock fsck -f /dev/vgubuntu/root resize2fs /dev/vgubuntu/root 12G lvresize --size 12G /dev/vgubuntu/root Once that is done you can continue the boot into the system in recovery mode and configure SIP. The sip-init command will setup the /var and /home filesystems, add them to /etc/fstab , relocate /tmp , build the initial dmverity hashes, and add the signed linux to the efi boot menu: Warning There is a high risk of data loss if the sip-init command is unable to complete. Either run this on a machine that doesn't have important data, or be certain that you have a good backup. sudo safeboot sip-init Hashing and signing the RO root filesystem When exiting recovery mode it is necessary to rehash the root filesystem and sign the kernel command line: sudo safeboot linux-sign The linux-sign command will: unmount / and remount it ro fsck / to ensure that it is clean run veritysetup format to compute the Merkle-tree for /dev/vgubuntu/root write the hashes to /dev/vgubuntu/hashes merge the linux kernel, initrd, and a command line with the dmverity root hash into an EFI executable sign this executable and install it as the default entry in the EFI boot manager Because this might change the EFI boot manager, it is necessary to reboot into the SIP mode and then re-seal the TPM key with safeboot luks-seal as documented above. TODO: Detect changes and notify the use rather than just EIO . Updates Nothing ever stays static, so it is important to consider the steps for updating the system. Frequently the root file system and kernel will be updated together, so these steps can be batched. Hopefully TPM re-sealing doesn't have to happen as often, since it requires access to the disk encryption recovery key. Root filesystem updates To re-enter recovery mode, remount the / filesystem read/write and re-hash the filesystem for normal mode: sudo safeboot recovery-reboot # enter the disk recovery password and login sudo safeboot remount # do stuff to / like apt-get ... sudo safeboot linux-sign sudo safeboot pcrs-sign reboot The recovery-reboot and remount subcommands: Set the UEFI Boot Manager BootNext to recovery Reboot the machine Require a manual disk decryption recovery code Runs blockdev --setrw to re-enable writes to the root device Runs mount -o rw,remount / to re-enable writes to the root filesystem After updating the file system with tools like apt install ... , the linux-sign subcommand will: Run mount -o ro,remount / to make the root filesystem readonly fsck / to ensure that it is clean veritysetup format to compute the merkle-tree Use the Yubikey or OpenSSL key to sign the merkle-tree root hash Reboot to the new read-only runtime The pcrs-sign subcommand will: Compute the expected PCR4 value for the new Linux kernel + initrd Sign it along with the other PCR values Store the signature on the PCR in a UEFI NVRAM variable If you are maintaining a fleet of machines, these could be done offline and the block image pushed to the system for installation. Note that while the PCR4 value can be predicted, the other PCRs might be machine specific. More research is necessary for proper fleet management. Kernel and initramfs update Re-generate /boot/initrd and /boot/vmlinuz Merge the kernel, initrd and command line into a single EFI executable Use the hardware token to sign that executable Copy the signed image to the EFI boot partition These could be done offline and the block image pushed to the system for installation UEFI firmware update If there are any updates to the UEFI firmware, such as changing the Setup variable, then the TPM sealed keys will no longer be accessible. From the recovery mode should be possible to sign the new PCRs (currently it requires more facilities than are available in the recovery initrd), or the recovery key can be used to mount the disk and re-seal the drive.","title":"Installation"},{"location":"install/#tldr","text":"Set UEFI SecureBoot setup mode Install Ubuntu 20.04, configure encrypted LVM partition Resizing '/' to 8GB during the install if you want to enable SIP wget https://github.com/osresearch/safeboot/releases/download/release-0.7/safeboot_0.7_amd64.deb sudo apt install safeboot_0.7_amd64.deb sudo update-initramfs -u sudo safeboot yubikey-init /CN=foo/ # or safeboot key-init if you don't have a token sudo safeboot uefi-sign-keys sudo safeboot recovery-sign sudo safeboot recovery-reboot # Should reboot into the recovery image. Login as usual. sudo safeboot luks-seal sudo update-initramfs -u sudo safeboot sip-init # if you want to enable SIP mode sudo safeboot recovery-sign sudo safeboot recovery-reboot # Should reboot into the recovery image again, with `/` mounted read-only. sudo safeboot linux-sign sudo reboot # Reboot one more time, now into dmverity protect Linux image... sudo safeboot luks-seal sudo reboot After this final reboot, the UEFI SecureBoot database will have the public signing keys, the UEFI boot manager will have entries for linux (which boots with a read-only dmverity protected root filesystem) and recovery (which boots with a root filesystem that can be remounted read-write), TPM should contain the disk encryption secret sealed to the linux boot mode, and now the disk should unlock automatically as long as no one tampers with the device. For more details as to how this all works, read on...","title":"tl;dr"},{"location":"install/#initial-setup","text":"This is done once when the system is being setup to use Safe Boot mode. Note that the hardware token and key signing portions can be done offline on a separate disconnected machine and then signed keys copied to the machine.","title":"Initial Setup"},{"location":"install/#uefi-firmware-configuration","text":"The goal of these configuration changes are to remove several of the easy attacks such as booting from external disks, modifying kernel or initrd on disk, changing kernel command line parameters, as well as some of the more esoteric ones like DMA attacks against the Thunderbolt ports during the boot process. SecureBoot: Enter setup mode, erase keys Supervisor password (do not lose it! it is very difficult to bypass) Tamper switches: require supervisor password Thunderbolt 3: Disabled TPM: Enabled","title":"UEFI firmware configuration"},{"location":"install/#uefi-secure-boot-signing-keys","text":"UEFI Secure Boot settings that the system will only run bootloaders that are signed by keys in the SPI flash. By default these keys are the OEM and Microsoft, and Microsoft will sign anyone else's key for $99, so it is important to replace these keys with ones under control of the computer owner. There is typically a signed \"shim\" that transfers control to the unsigned grub bootloader and kernel, which is problematic for security. A safer way to boot is to package the kernel, initrd and command line into a single EFI executable that is signed by the computer owner's key. This also reduces the attack surface by removing grub and the overly complicated config files, as well as speeds up the boot process a little bit. The owner key can be generated by openssl and stored offline, although using a hardware token like a yubikey greatly enhances the security of the system since even with root access an attacker can't gain persistence in the / or in the kernel.","title":"UEFI Secure Boot signing keys"},{"location":"install/#openssl-key-generation","text":"First step is to generate a new key that will be used for UEFI SecureBoot: sudo safeboot key-init /CN=foo/OU=bar/O=example.com/ The key-init subcommand will generate a password protected RSA2048 key and store it in /etc/safeboot/ along with the public certificate. The password provided here will be required to sign new kernel images and initrds, so don't lose it! TODO: What is the purpose of the x509 subject?","title":"OpenSSL key generation"},{"location":"install/#yubikey-key-generation","text":"Note Skip this if you have already initialized your hardware token and enrolled your keys in the UEFI SecureBoot database. Running it again will erase the keys from your hardware token. First step is to generate a new key that will be used for UEFI SecureBoot: sudo safeboot yubikey-init /CN=foo/OU=bar/O=example.com/ The yubikey-init subcommand will do several steps: Use ykpersonalize to enable CCID mode. (TODO) Generate a new private key inside the Yubikey and export the public key Self-sign the public key to generate a new x509 certificate Reimport the certificate into the Yubikey so that UEFI variables and images can be signed with the hardware token. The public certificate is stored in /etc/safeboot/cert.pem . The private key never leaves the hardware token so it is much more difficult for an adversary to clone.","title":"Yubikey key generation"},{"location":"install/#enrolling-uefi-platform-keys","text":"Replacing the UEFI Platform Key with the generated x509 cert requires that the UEFI SecureBoot firmware be put into \" Setup mode \". On the Thinkpads, select Reset to Setup Mode and Clear All Secure Boot Keys , then boot into Linux. To load the public key from /etc/safeboot/cert.pem into the UEFI secure boot key database: sudo safeboot uefi-sign-keys Once the key has been generated, the x509 certificate needs to be reformatted to be added to the UEFI Secure Boot platform key ( PK ), Key-Exchange Key ( KEK ) and as a key database entry ( db ). Each of these updates needs to be signed with the Platform Key; in the case of the PK it is self-signed. The safeboot uefi-sign-keys subcommand will: Generate the three EFI public key variables updates (UEFI platform key ( PK ), key-exchange key ( KEK ) and database ( db )) Sign the EFI variables with the Yubikey or OpenSSL key (will require a PIN authentication for each variable) Store the signed public certificates into the firmware. Danger Before you reboot! If you have not signed the kernel and initrd as described above, the system will not boot and you will have to disable UEFI Secure Boot to get back into the machine.","title":"Enrolling UEFI Platform Keys"},{"location":"install/#signed-linux-recovery-kernel","text":"Warning If you don't have a recovery entry in the EFI boot manager on the disk, you would need to have a USB drive signed with a key in the UEFI db to recover from errors. The next step is to use the Yubikey or OpenSSL key to sign and install a recovery kernel, which will be able to read/write mount the root filesystem, and does not have TPM sealing keys, so it will always require a recovery password to decrypt the disk. sudo safeboot recovery-sign This command will: Add UEFI boot menu item for recovery kernel Create a directory for it in the EFI System Partition (\"ESP\") Merge the vmlinux, initrd and command line into a single EFI executable Sign the merged EFI executable Typically you will not have to redo this command since the normal kernel will be hashed and signed during updates. The one exception is that once SIP mode is enabled you will have to resign the recovery image as well to ensure that it doesn't accidentally write to the / file system and corrupt the hashes.","title":"Signed Linux recovery kernel"},{"location":"install/#tpm-configuration","text":"The commands to seal the LUKS disk encryption key into the TPM, rebuild the initrd, sign the kernel/initrd, and update the expected PCR values are: sudo safeboot luks-seal sudo safeboot linux-sign sudo safeboot pcrs-sign You only need to run safeboot luks-seal the very first time; the sealed secret is included in the initrd image (stored in /etc/safeboot/sealed.secret ). When a new kernel or initrd is built, the platform key is used to sign both the kernel+initrd unified image, as well as the PCRs that go with it. The luks-seal subcommand will: Prompt for a decryption PIN, unless SEAL_PIN=0 in /etc/safeboot/local.conf Create a new disk encryption key with random data Add new key slot to disk with new key (will require the recovery password) Create a TPM policy that requires the PCRs defined in $PCRS to match a signed block Seal the disk encryption key with that policy and store it in /etc/safeboot/sealed.secret Add initramfs building hooks to unseal the secret Modify /etc/crypttab entry to call unlock script if necessary The Trusted Platform Module serves two purposes in securing the process: it helps validate that the firmware and boot configuration is unchanged, and it streamlines the boot process by providing the key for encrypted disks. On modern systems Boot Guard ensures that the initial boot block is measured into the TPM, so a local attacker shouldn't be able to modify the SPI flash contents to bypass the measurements, or to add their own keys to the UEFI key database. (Subject to various CVE's and TOCTOUs, etc) Note The TPM PCRs are somewhat fragile; they include hashes of the ROM images, the EFI executables that have been run along the boot path, etc. For example, entering the UEFI Setup menu will cause different measurements, so the TPM will not automatically unseal on the same boot that the user has entered the setup application. For normal operation only a direct boot into the unified kernel+initrd will automatically decrypt. When a new kernel is installed or the initrd needs to be updated, it is only necessary to sign the kernel and PCRs. The sealed LUKS key is no longer changed and the recovery password is not required. sudo safeboot linux-sign sudo safeboot pcrs-sign","title":"TPM Configuration"},{"location":"install/#system-integrity-protection-mode","text":"Note The \"SIP\" mode is optional and ensures that even an attacker with root priviledges can't make persistent changes to the contents of the root filesystem. It uses the same dmverity as Android's verified boot mode . The root of the dm-verity Merkle-tree is passed to the kernel as part of the signed command line, ensuring that an attacker can't change anything on the filesystem without access to the signing key. Any modifications to the filesystem will be detected when the modified blocks are read, allowing the system to enter recovery mode to protect its data.","title":"System Integrity Protection mode"},{"location":"install/#ro-and-rw-partition-setup","text":"Resizing the root filesystem is necessary so that it can be made read-only, as well as to make space for /home and /var as separate writable mounts, and also so that dmverity hash computation doesn't take forever. The partition resize to prepare the system for SIP mode must be done from the recovery shell, since the root file system can't be mounted while it is being modified. Warning There is a high risk of data loss if these commands are mistyped or if the resize2fs fails. Either run this on a machine that doesn't have important data, or be certain that you have a good backup. In the recovery shell, run these commands to decrypt the root disk, make sure it is clena, resize the filesystem, and then resize the logical volume. No need for sudo , since the recovery shell is always root. crypt_unlock fsck -f /dev/vgubuntu/root resize2fs /dev/vgubuntu/root 12G lvresize --size 12G /dev/vgubuntu/root Once that is done you can continue the boot into the system in recovery mode and configure SIP. The sip-init command will setup the /var and /home filesystems, add them to /etc/fstab , relocate /tmp , build the initial dmverity hashes, and add the signed linux to the efi boot menu: Warning There is a high risk of data loss if the sip-init command is unable to complete. Either run this on a machine that doesn't have important data, or be certain that you have a good backup. sudo safeboot sip-init","title":"RO and RW Partition setup"},{"location":"install/#hashing-and-signing-the-ro-root-filesystem","text":"When exiting recovery mode it is necessary to rehash the root filesystem and sign the kernel command line: sudo safeboot linux-sign The linux-sign command will: unmount / and remount it ro fsck / to ensure that it is clean run veritysetup format to compute the Merkle-tree for /dev/vgubuntu/root write the hashes to /dev/vgubuntu/hashes merge the linux kernel, initrd, and a command line with the dmverity root hash into an EFI executable sign this executable and install it as the default entry in the EFI boot manager Because this might change the EFI boot manager, it is necessary to reboot into the SIP mode and then re-seal the TPM key with safeboot luks-seal as documented above. TODO: Detect changes and notify the use rather than just EIO .","title":"Hashing and signing the RO root filesystem"},{"location":"install/#updates","text":"Nothing ever stays static, so it is important to consider the steps for updating the system. Frequently the root file system and kernel will be updated together, so these steps can be batched. Hopefully TPM re-sealing doesn't have to happen as often, since it requires access to the disk encryption recovery key.","title":"Updates"},{"location":"install/#root-filesystem-updates","text":"To re-enter recovery mode, remount the / filesystem read/write and re-hash the filesystem for normal mode: sudo safeboot recovery-reboot # enter the disk recovery password and login sudo safeboot remount # do stuff to / like apt-get ... sudo safeboot linux-sign sudo safeboot pcrs-sign reboot The recovery-reboot and remount subcommands: Set the UEFI Boot Manager BootNext to recovery Reboot the machine Require a manual disk decryption recovery code Runs blockdev --setrw to re-enable writes to the root device Runs mount -o rw,remount / to re-enable writes to the root filesystem After updating the file system with tools like apt install ... , the linux-sign subcommand will: Run mount -o ro,remount / to make the root filesystem readonly fsck / to ensure that it is clean veritysetup format to compute the merkle-tree Use the Yubikey or OpenSSL key to sign the merkle-tree root hash Reboot to the new read-only runtime The pcrs-sign subcommand will: Compute the expected PCR4 value for the new Linux kernel + initrd Sign it along with the other PCR values Store the signature on the PCR in a UEFI NVRAM variable If you are maintaining a fleet of machines, these could be done offline and the block image pushed to the system for installation. Note that while the PCR4 value can be predicted, the other PCRs might be machine specific. More research is necessary for proper fleet management.","title":"Root filesystem updates"},{"location":"install/#kernel-and-initramfs-update","text":"Re-generate /boot/initrd and /boot/vmlinuz Merge the kernel, initrd and command line into a single EFI executable Use the hardware token to sign that executable Copy the signed image to the EFI boot partition These could be done offline and the block image pushed to the system for installation","title":"Kernel and initramfs update"},{"location":"install/#uefi-firmware-update","text":"If there are any updates to the UEFI firmware, such as changing the Setup variable, then the TPM sealed keys will no longer be accessible. From the recovery mode should be possible to sign the new PCRs (currently it requires more facilities than are available in the recovery initrd), or the recovery key can be used to mount the disk and re-seal the drive.","title":"UEFI firmware update"},{"location":"safeboot/","text":"Safe Boot subcommands Usage: safeboot subcommand [options...] key-init Usage: safeboot key-init \"subject\" Generate a new x509 signing key with openssl, writing storing the public key in /etc/safeboot/cert.pem and the password protected private key in /etc/safeboot/signing.key . This is not as secure as storing it in a hardware token, although if the key is moved to an external device and the $KEY variable in /etc/safeboot/local.conf updated to point to it, then it will prevent a software-only attack. The subject must be written as a \"distinguished name\": /CN=host.example.com/OU=test/O=example.com/ yubikey-init Usage: safeboot yubikey-init \"subject\" Generate a new x509 signing key on an attached Yubikey device and set the certificate subject to the provided argument. The public key certificate will be written to /etc/safeboot/cert.pem and will also be used for the UEFI SecureBoot variables. Due to a limitation in the OpenSSL PKCS11 engine, you have to enter the password multiple times (once for the engine, and then once for the signature). The subject must be written as a \"distinguished name\": /CN=host.example.com/OU=test/O=example.com/ yubikey-pubkey Usage: safeboot yubikey-pubkey cert.pem Extract the public key certificate in PEM, DER and PUB format. The sbsign tool wants PEM, the kmodsign tool wants DER, the tpm2-tools wants a raw public key. The best part about standards... uefi-sign-keys Usage: safeboot uefi-sign-keys Create three signed certificates for the PK, KEK, and db using the attached Yubikey or x509 key stored in /etc/safeboot/signing.key and store them in the UEFI SecureBoot configuration. You should have run safeboot yubikey-init or safeboot key-init to have already generated the keys. Due to an issue with the OpenSSL PKCS11 engine, you will have to authenticate to the Yubikey multiple times during this process. uefi-set-keys Usage: safeboot uefi-set-keys Store the PK, KEK, and db into the UEFI Secure Boot configuration variables. This must be done once during system setup or if a new key is generated. The uefi-sign-key subcommand attempts to do this automatically. pcrs-sign Usage: safeboot pcrs-sign [prevent-rollback] [path-to-unified-kernel] Generate a signature for the PCRs that can be used to unseal the LUKS key according to the policy created by safeboot luks-seal . The PCRs used are specified in the /etc/safeboot/safeboot.conf or local.conf files, and must match the values that were configured during luks-seal . If the prevent-rollback argument is prevent-rollback , the TPM version counter will be incremented, which will invalidate all previous PCR signatures and prevent the older unified kernel images from being able to unseal the PCR data. The signature is persisted in a UEFI NVRAM variable, defined in safeboot.conf . luks-seal Usage: safeboot luks-seal This will generate a new LUKS encryption key for the block device in /etc/crypttab and requires an existing recovery key to install the new key slot. You will also be prompted for an unlock PIN, which will be required on the next normal boot in place of the recovery code. If this is the first time the disk has been sealed, /etc/crypttab will be updated to include a call to the unsealing script to retrieve the keys from the TPM, and a counter will be created to prevent rollbacks. After sealing the secret, the initrd will be rebuild, the kernel signed, and the new predicted PCRs signed. Any previous sealed data will be invalidated since the version counter will be incremented. Right now only a single crypt disk is supported. sign Usage: safeboot sign exe [exe.signed] Sign an EFI executable with the safeboot keys. This is the raw command; you might want to use safeboot linux-sign or safeboot recovery-sign instead. unify-kernel Usage: safeboot unify-kernel linux.efi kernel=path-to-kernel initrd=path-to-initrd ... Creates a unified kernel image with the named sections and files (typically kernel , initrd , cmdline , and osrel ) bundled into an EFI executable. This is the raw command; you might want to use safeboot linux-sign or safeboot recovery-sign instead to add the EFI boot manager entry. sign-kernel Usage: safeboot sign-kernel linux.efi [linux.signed.efi] Sign a unified EFI executable with the safeboot keys. If no destination is specified it will be the same name as the input kernel with .signed.efi added. This is the raw command; you might want to use safeboot linux-sign or safeboot recovery-sign instead to add the EFI boot manager entry. install-kernel Usage: safeboot install-kernel boot-name [extra kernel parameters...] Create an EFI boot menu entry for boot-name , with the specified kernel, initrd and command line bundled into an executable and signed. This command requires the Yubikey or x509 password to be able to sign the merged EFI executable. This is the raw command; you might want to use safeboot linux-sign or safeboot recovery-sign instead. linux-sign Usage: safeboot linux-sign [target-name [parameters...]] Generate dm-verity hashes and then sign the Linux with the root hash added to the kernel command line. The default target for the EFI boot manager is linux . You will need the Yubikey or x509 password to sign the new hashes and kernel. If the environment variable $HASH is set to the hash value, or if the $HASHFILE variable points to the previous dmverity log (typically /boot/efi/EFI/linux/verity.log ), then the precomputed value will be used instead of recomputing the dmverity hashes (which can take some time). If the hashes are out-of-date, this might render the linux target unbootable and require a recovery reboot to re-hash the root filesystem. recovery-sign Usage: safeboot recovery-sign [kernel command line...] Sign the Linux kernel and initrd into the EFI boot manager recovery entry. Typically this only needs to be done once and after validating that the system can boot with it, you should not have to re-run this command. You will need the Yubikey or x509 password as well as root accesss to perform this action. If SIP is enabled the root device will be marked read-only for the reboot and fscked will not been run on boot. Use safeboot remount to remount / as read-write when in recovery mode, and then safeboot remount ro to restore it to read-only mode before signing the hashes. recovery-reboot Usage: safeboot recovery-reboot Configure the EFI boot manager so that the BootNext is the recovery target and reboot the machine. This command requires root access to update the EFI variables and will also require the disk encryption recovery key since the TPM will not unseal the disk automatically for recovery mode. NOTE! This will reboot the machine! bootnext Usage: safeboot bootnext Setup Configure the EFI boot manager BootNext variable to select an alternate boot menu item. This command requires root access to update the EFI variables. remount Usage: safeboot remount [ro] Attempt to remount the root filesystem read/write or read-only. If SIP is enabled this will likely invalidate any hashes and require a re-signing of the root filesystem. If ro is specified, then the file system will be re-mounted read-only If there are processes blocking the remount, they will be listed. sip-init Usage: safeboot sip-init [home-size-in-GB [var-size]] DANGER! This command can mess up your root filesystem. There must be space in the volume group for the new entries It will create the volume groups for /var and /home , add entries to /etc/fstab for them with secure mount parameters, and makes /tmp a symlink into /var/tmp . unlock Usage: safeboot unlock This is a recovery shell command to scan the /etc/crypttab for devices and call cryptsetup luksOpen on each of them, and then scan the LVM groups for volumes. After it succeeds you can call safeboot mount to mount the root filesystem (read-only) on /root . mount-all Usage: safeboot mount-all This is a recovery shell command to attempt to mount the root disk read-only on /root , as well as the /boot and /boot/efi if they exist in /root/etc/fstab .","title":"safeboot subcommands"},{"location":"safeboot/#safe-boot-subcommands","text":"Usage: safeboot subcommand [options...]","title":"Safe Boot subcommands"},{"location":"safeboot/#key-init","text":"Usage: safeboot key-init \"subject\" Generate a new x509 signing key with openssl, writing storing the public key in /etc/safeboot/cert.pem and the password protected private key in /etc/safeboot/signing.key . This is not as secure as storing it in a hardware token, although if the key is moved to an external device and the $KEY variable in /etc/safeboot/local.conf updated to point to it, then it will prevent a software-only attack. The subject must be written as a \"distinguished name\": /CN=host.example.com/OU=test/O=example.com/","title":"key-init"},{"location":"safeboot/#yubikey-init","text":"Usage: safeboot yubikey-init \"subject\" Generate a new x509 signing key on an attached Yubikey device and set the certificate subject to the provided argument. The public key certificate will be written to /etc/safeboot/cert.pem and will also be used for the UEFI SecureBoot variables. Due to a limitation in the OpenSSL PKCS11 engine, you have to enter the password multiple times (once for the engine, and then once for the signature). The subject must be written as a \"distinguished name\": /CN=host.example.com/OU=test/O=example.com/","title":"yubikey-init"},{"location":"safeboot/#yubikey-pubkey","text":"Usage: safeboot yubikey-pubkey cert.pem Extract the public key certificate in PEM, DER and PUB format. The sbsign tool wants PEM, the kmodsign tool wants DER, the tpm2-tools wants a raw public key. The best part about standards...","title":"yubikey-pubkey"},{"location":"safeboot/#uefi-sign-keys","text":"Usage: safeboot uefi-sign-keys Create three signed certificates for the PK, KEK, and db using the attached Yubikey or x509 key stored in /etc/safeboot/signing.key and store them in the UEFI SecureBoot configuration. You should have run safeboot yubikey-init or safeboot key-init to have already generated the keys. Due to an issue with the OpenSSL PKCS11 engine, you will have to authenticate to the Yubikey multiple times during this process.","title":"uefi-sign-keys"},{"location":"safeboot/#uefi-set-keys","text":"Usage: safeboot uefi-set-keys Store the PK, KEK, and db into the UEFI Secure Boot configuration variables. This must be done once during system setup or if a new key is generated. The uefi-sign-key subcommand attempts to do this automatically.","title":"uefi-set-keys"},{"location":"safeboot/#pcrs-sign","text":"Usage: safeboot pcrs-sign [prevent-rollback] [path-to-unified-kernel] Generate a signature for the PCRs that can be used to unseal the LUKS key according to the policy created by safeboot luks-seal . The PCRs used are specified in the /etc/safeboot/safeboot.conf or local.conf files, and must match the values that were configured during luks-seal . If the prevent-rollback argument is prevent-rollback , the TPM version counter will be incremented, which will invalidate all previous PCR signatures and prevent the older unified kernel images from being able to unseal the PCR data. The signature is persisted in a UEFI NVRAM variable, defined in safeboot.conf .","title":"pcrs-sign"},{"location":"safeboot/#luks-seal","text":"Usage: safeboot luks-seal This will generate a new LUKS encryption key for the block device in /etc/crypttab and requires an existing recovery key to install the new key slot. You will also be prompted for an unlock PIN, which will be required on the next normal boot in place of the recovery code. If this is the first time the disk has been sealed, /etc/crypttab will be updated to include a call to the unsealing script to retrieve the keys from the TPM, and a counter will be created to prevent rollbacks. After sealing the secret, the initrd will be rebuild, the kernel signed, and the new predicted PCRs signed. Any previous sealed data will be invalidated since the version counter will be incremented. Right now only a single crypt disk is supported.","title":"luks-seal"},{"location":"safeboot/#sign","text":"Usage: safeboot sign exe [exe.signed] Sign an EFI executable with the safeboot keys. This is the raw command; you might want to use safeboot linux-sign or safeboot recovery-sign instead.","title":"sign"},{"location":"safeboot/#unify-kernel","text":"Usage: safeboot unify-kernel linux.efi kernel=path-to-kernel initrd=path-to-initrd ... Creates a unified kernel image with the named sections and files (typically kernel , initrd , cmdline , and osrel ) bundled into an EFI executable. This is the raw command; you might want to use safeboot linux-sign or safeboot recovery-sign instead to add the EFI boot manager entry.","title":"unify-kernel"},{"location":"safeboot/#sign-kernel","text":"Usage: safeboot sign-kernel linux.efi [linux.signed.efi] Sign a unified EFI executable with the safeboot keys. If no destination is specified it will be the same name as the input kernel with .signed.efi added. This is the raw command; you might want to use safeboot linux-sign or safeboot recovery-sign instead to add the EFI boot manager entry.","title":"sign-kernel"},{"location":"safeboot/#install-kernel","text":"Usage: safeboot install-kernel boot-name [extra kernel parameters...] Create an EFI boot menu entry for boot-name , with the specified kernel, initrd and command line bundled into an executable and signed. This command requires the Yubikey or x509 password to be able to sign the merged EFI executable. This is the raw command; you might want to use safeboot linux-sign or safeboot recovery-sign instead.","title":"install-kernel"},{"location":"safeboot/#linux-sign","text":"Usage: safeboot linux-sign [target-name [parameters...]] Generate dm-verity hashes and then sign the Linux with the root hash added to the kernel command line. The default target for the EFI boot manager is linux . You will need the Yubikey or x509 password to sign the new hashes and kernel. If the environment variable $HASH is set to the hash value, or if the $HASHFILE variable points to the previous dmverity log (typically /boot/efi/EFI/linux/verity.log ), then the precomputed value will be used instead of recomputing the dmverity hashes (which can take some time). If the hashes are out-of-date, this might render the linux target unbootable and require a recovery reboot to re-hash the root filesystem.","title":"linux-sign"},{"location":"safeboot/#recovery-sign","text":"Usage: safeboot recovery-sign [kernel command line...] Sign the Linux kernel and initrd into the EFI boot manager recovery entry. Typically this only needs to be done once and after validating that the system can boot with it, you should not have to re-run this command. You will need the Yubikey or x509 password as well as root accesss to perform this action. If SIP is enabled the root device will be marked read-only for the reboot and fscked will not been run on boot. Use safeboot remount to remount / as read-write when in recovery mode, and then safeboot remount ro to restore it to read-only mode before signing the hashes.","title":"recovery-sign"},{"location":"safeboot/#recovery-reboot","text":"Usage: safeboot recovery-reboot Configure the EFI boot manager so that the BootNext is the recovery target and reboot the machine. This command requires root access to update the EFI variables and will also require the disk encryption recovery key since the TPM will not unseal the disk automatically for recovery mode. NOTE! This will reboot the machine!","title":"recovery-reboot"},{"location":"safeboot/#bootnext","text":"Usage: safeboot bootnext Setup Configure the EFI boot manager BootNext variable to select an alternate boot menu item. This command requires root access to update the EFI variables.","title":"bootnext"},{"location":"safeboot/#remount","text":"Usage: safeboot remount [ro] Attempt to remount the root filesystem read/write or read-only. If SIP is enabled this will likely invalidate any hashes and require a re-signing of the root filesystem. If ro is specified, then the file system will be re-mounted read-only If there are processes blocking the remount, they will be listed.","title":"remount"},{"location":"safeboot/#sip-init","text":"Usage: safeboot sip-init [home-size-in-GB [var-size]] DANGER! This command can mess up your root filesystem. There must be space in the volume group for the new entries It will create the volume groups for /var and /home , add entries to /etc/fstab for them with secure mount parameters, and makes /tmp a symlink into /var/tmp .","title":"sip-init"},{"location":"safeboot/#unlock","text":"Usage: safeboot unlock This is a recovery shell command to scan the /etc/crypttab for devices and call cryptsetup luksOpen on each of them, and then scan the LVM groups for volumes. After it succeeds you can call safeboot mount to mount the root filesystem (read-only) on /root .","title":"unlock"},{"location":"safeboot/#mount-all","text":"Usage: safeboot mount-all This is a recovery shell command to attempt to mount the root disk read-only on /root , as well as the /boot and /boot/efi if they exist in /root/etc/fstab .","title":"mount-all"},{"location":"threats/","text":"safeboot intends to protect the integrity of the boot process and runtime integrity of the system against adversaries with external physical access to the device, as well as limited internal physical access. The assumption is that the attacker can get code execution on the device as the user and as root, but does not have access to the signing keys or the disk encryption key. The goal is to prevent the attacker from exfiltrating data from the device or making persistent changes to the system configuration. The protections offered by UEFI Secure Boot fall short of these goals in several areas. The default signing keys in Secure Boot are not under control of the computer owner -- the bootloader root CA keys are controlled by Microsoft, who signs the keys used to sign the shim bootloader, which has the Linux distribution keys built in. Owners can enroll their keys to the Machine Owner Key (MOK), but this does not replace the distribution keys in the shim. Even with SecureBoot enabled, most distributions still go through grub for a boot menu, which increases the attack surface and adds another layer of validation that needs to be done. Finally, Canonical signs the kernel and the kernel modules so that they are accepted by the shim and grub, but the initrd is unsigned and an attacker can replace it without too much difficulty since it is stored in plaintext on the disk. Additionally, none of the Linux distributions support TPM protected keys out of the box, which is why it is necessary to install a package like safeboot to make use of them. Protections The protections that are applied by the /usr/sbin/safeboot script and setup instructions include: Firmware Enabling UEFI Secure Boot, Supervisor password, Tamper Switches, etc Generating an owner controlled signing key in a hardware token Installing the owner's signing key as the UEFI Secure Boot Platform Key ( PK ) Removing OEM and Microsoft keys from the UEFI Secure Boot key database ( db ) Signing the kernel, initrd and command line with the owner's hardware key Booting LUKS block device encryption on / , /home , /var and swap. TPM Sealing the disk encryption key with the UEFI firmware and configuration values The TPM sealed secret can be protected with a PIN The TPM sealed secret can be protected from rollback with a TPM counter If unsealing fails, attesting to the firmware state with TOTP and using a recovery key Storing the unsealed key in a protected kernel keyring and logging Enabling intel_iommu=on and efi=disable_early_pci_dma to eliminate some hardware attacks Runtime Enabling lockdown=confidentiality mode to prevent root from accessing keyrings or memory Mounting the root filesystem read-only and marking the block device read-only Enabling dmverity hash checking on the root filesystem (\"SIP\" mode) Mounting /tmp , /home and /var with nosuid,nodev Removing Canonical's module signing key Adding usb-storage and other external media to the kernel module deny list Proving the firmware and kernel configuration to remote attestation servers with tpm2-attest Todo TODO: Flush encryption keys during sleep TODO: VPN config TODO: Prevent network reconfiguration TODO: Device VM separation TODO: Separate /home encryption TODO: Multiparty signatures for higher assurance TODO: Allowed list of USB device IDs. The behaviour of things like the tamper switches and supervisor password are as observed on the Lenovo X1 firmware (and some were fixed after reporting vulnerabilities to Lenovo); other devices may vary and have less secure behaviour. Attacks These changes protect against many local physical and software attacks. Physical hardware attacks A local attacker with physical access to the device can open the device to gain access to the drive, the SPI flash on the mainboard, the Management Engine and CPU chipset, the discrete TPM device, the RAM chips, PCIe buses (such as m.2 slots), etc. Opening the case to modify the flash or modify devices will trip the case tamper switch and prevent the device from booting until the firmware supervisor password is entered. This detects several classes of \"evil maid\" attacks that require physical access. Removing the disk to attempt to rewrite it or image it for offline attacks will trigger both the case tamper switch and the disk tamper switch. The firmware supervisor password is required to reboot, which will allow the user or administrator to detect that the device has been compromised. On Lenovo's recent firmware, the supervisor password is not stored in the SPI flash, but in the EC, and changing it requires the EC to validate the change. This prevents a local attacker from modifying the NVRAM variabels in the SPI flash to bypass the supervisor checks. However, the EC is an open field of security research. On Lenovo's recent firmware, the tamper switch state is stored in the EC, rather than the RTC RAM. This makes it more difficult to bypass the tamper switches since an EC or Bootguard attack is necessary. Exploits against the ME are unlikely to be detectable, although they require a level of expertise to pull off and do not provide persistence. A local attacker could use this to bypass Bootguard and other TPM provided protections. If they also know the TPM PIN and /home encryption password, they can exfiltrate data, but are unlikely to be able to gain persistence without the attack device in place due to the signed dmverity hashes. Changing the firmware in the SPI flash should be detected by Intel Bootguard's verification of the IBB during boot up and result in the device not booting. There are public TOCTOU attacks against Bootguard, so a local attacker can bypass the measured root of trust to boot their unsigned firmware and kernel. As with the ME attacks, if the TPM PIN and /home encryption key are known then data can be exfiltrated, but this does not provide persistence. Writing new platform keys in the SPI flash will result in a TPM unsealing failure since the UEFI secure boot configuration is part of the measured state included in the TPM PCRs. An attack that presents a fake recovery key input dialog can be detected by the tpm2-totp tool. The TPM2 will only generate the 30-second, 6-digit authentication code if the PCRs match the expected value and the administrator can verify it against their authenticator app. With TPM2, the HMAC is computed in the TPM itself, so the secret is never accessible to the operating system. The PCR values in the TPM are not \"secret\", so an adversary with physical access could directly wire to the TPM and provide it with the correct measurements to extend the PCRs to match the signed values. The user PIN is still necessary to unseal the secret and the TPM dictionary attack protections both rate-limit and retry-limit the attacker. Discrete TPM tampering on the LPC bus is not necessarily detectable by this system; an adversary with unlimited internal physical access can also probe sealed secrets. If a TPM PIN is used then the secrets might be brute-forcable, but would require much longer internal access. Functional TPM tampering is out of scope since the fTPM is an application running inside the Intel Management Engine, not a separate device, and the ME is the root of all trust in the system. An adversary with code execution on the ME is able to bypass all of the other platform protections (with maybe the exception of SGX enclaves, although this is not certain). In a \"Coldboot\" attacks on the memory , an attack triggers a reboot in order to boot into their own kernel that doesn't clear memory. Since most of the old contents are still present, this custom kernel can read through memory to look for secrets. This attack is prevented by requiring valid owner signatures on any kernel, and could be additionally prevented by enabling Intel TXT with an enforced DRAM clear, although a physically proximate attacker can turn off those protections by modifying the NVRAM variables during the boot process. In another variant of the coldboot attack, the attacker freezes the RAM chips with cooling spray, removes the physical memory modules and install them into a new system that the attacker controls and that is configured to not clear the memory on power up. This attack is not easily doable on the X1 since all of the RAM is soldered onto mainboard, but is possible against part of the memory on the T490 since it has some of its memory soldered and some on a DIMM. TODO: Can Linux restrict the keys to the hard soldered chips? The encryption keys are stored in RAM even while the system is asleep, which makes the keys potentially available to an attacker with certain resources; it would be worthwhile to consider flushing them prior to entering S3 suspend. This would require modifying the init scripts that handle resume to prompt for the password; the TPM sealed encryption keys are problematic since the TPM state is reloaded during a resume. Physical software attacks Modifying the unencrypted kernel or initrd on /boot or attempting to pass in unapproved kernel command line parameters is prevented by the UEFI Secure Boot signature checks. The firmware will not hand control of the system to an unsigned EFI executable, which in this case is the entire kernel, initrd, and command line. This prevents both physical rewriting the disk in another machine, as well as if an attacker escallates to root and remounts /boot as read-write. The boot order NVRAM variable could be modified by an attacker with access to the SPI flash or if they have escallated to root. However, booting from an external device still requires an EFI executable signed by the PK/KEK/db, and since the default signing keys (typically the OEM and Microsoft) have been removed, only images signed the the computer owner's key will be booted from the external USB flash drive. Adversaries might try to gain persistence or weaken security by gaining write access to the unencrypted /boot partition and changing the kernel images. This requires either a root escalation or a tamper switch bypass, but the firmware will deny them peristence by refusing to boot from the modified image since the signature is checked when they are loaded into RAM at boot. There should not be any runtime TOCTOU since the DRAM has been initialized and there is space to store the entire image prior to validating the signature. The adversary might roll back to a prior version of the signed kernel and initrd, with a prior signed version of the PCRs. This is prevented by using monotonic TPM counter in addition to the signature. When a security critical update is available, the TPM counter is incremented and the PCRs are signed with that new value. The TPM will refuse to unseal older sealed data since the counter no longer matches. The TPM counter should be protected against rollback since deleting and re-creating a counter does not reset it to zero, but instead to the highest value that any counter in the TPM has ever reached. Adversaries might try to gain persistence by gaining write access to the encrypted and dmverity protected / filesystem, which requires a kernel escalation since dmverity prohibits writes to the protected block device, or a tamper switch bypass in addition to possession of the TPM disk unsealing keys. However, even with write access, the adversary can not gain persistence since the signed kernel command line and signed initrd enable dmverity hash checking, which will detect any modifications to / . They would also need access to the signing keys to be able to produce a new valid root hash. An adversary might try to gain run time access to the disk encryption key. The PCRs are extended with the booted state so that the TPM will no longer unseal it after the initrd, and root is prevented from reading the key from the Linux kernel keyring, so a kernel escallation is required to gain access to it. TODO: qubes style separate VM for disk and user? Some of the ports on the device, such as Thunderbolt and PCIe, have the ability to DMA in and out of main memory, which would allow a local attacker to connect a device that reads secrets out of unencrypted memory. The safeboot kernel commandline parameter configuration turns on the Intel IOMMU by default, as well as turns off PCIe bus-mastering, both of which should protect against attacks like Thunderspy as well as some classes of malicious devices on the Thunderbolt port or internal Mini-PCIe ports. Software attacks An attacker might try to exfiltrate data by plugging in a USB flash drive, which is prevented by adding usb-storage to the deny list. The USB ports could also be turned off in the UEFI Setup , although this would also prevent external keyboards and mice, if they are desired. An attacker with root access could try to load the USB storage module with insmod /lib/modules/..../usb-storage.ko , which bypasses the /etc/modprobe.d/ configuration. This can be prevented by removing the module from the root filesystem. An attacker with root access could download a version of the usb-storage module from the Ubuntu website, which is signed by the Canononical key and can be loaded into a stock kernel since their key is in the default key ring. This is prevented by building a custom kernel with a module signing key that is not stored on the machine. An attacker with root access could try to kexec into a custom kernel that doesn't overwrite the disk encryption key and that doesn't enforce external device access. This is prevented by the Linux kernel lockdown mode (turned on by UEFI Secure Boot mode) , which requires a signature on the new kernel by one of the keys in the UEFI Secure Boot key database, which only contains the public key of the hardware token used to sign the real kernel and initrd. An attacker with root access could try to bypass the module or kexec signature checks by opening /dev/mem or otherwise directly poking into memory to enable the hardware to escalate into kernel mode. The Lockdown patches also disable access to the memory device and prevent root from being able to adjust iopl or other special modes, which should make it more difficult for an attacker to escalate into kernel mode. An attacker with root access might try to use the Linux kernel keyring to read the disk encryption key. This is prevented by enabling lockdown=confidentiality mode , which prevent all kernel memory accesses from user space, and also ensures that the keyrings are not accessible. The attacker would require an additional privilege escalation is required to turn off lockdown. An attacker might try to escalate to root by somehow creating device files or mounting filesystems with SUID binaries. The /etc/fstab entries for /home and /var are configured to not allow such executables. TODO: Prevent network reconfiguration that bypasses mandatory VPN. TODO: ensure that the magic sysctl isn't allowed to bypass various security bits. Todo TODO: rollback attacks; how to use TPM counters to prevent them TODO: Document rebuilding the kernel TODO: configure allow/deny lists to clean up the module directories. TODO: SELinux config TODO: qubes/secureview separation TODO: /home encryption TODO: TPM PIN TODO: tpm-totp TODO: document how tpm2-attest handles access to remote resources","title":"Threat Model"},{"location":"threats/#protections","text":"The protections that are applied by the /usr/sbin/safeboot script and setup instructions include:","title":"Protections"},{"location":"threats/#firmware","text":"Enabling UEFI Secure Boot, Supervisor password, Tamper Switches, etc Generating an owner controlled signing key in a hardware token Installing the owner's signing key as the UEFI Secure Boot Platform Key ( PK ) Removing OEM and Microsoft keys from the UEFI Secure Boot key database ( db ) Signing the kernel, initrd and command line with the owner's hardware key","title":"Firmware"},{"location":"threats/#booting","text":"LUKS block device encryption on / , /home , /var and swap. TPM Sealing the disk encryption key with the UEFI firmware and configuration values The TPM sealed secret can be protected with a PIN The TPM sealed secret can be protected from rollback with a TPM counter If unsealing fails, attesting to the firmware state with TOTP and using a recovery key Storing the unsealed key in a protected kernel keyring and logging Enabling intel_iommu=on and efi=disable_early_pci_dma to eliminate some hardware attacks","title":"Booting"},{"location":"threats/#runtime","text":"Enabling lockdown=confidentiality mode to prevent root from accessing keyrings or memory Mounting the root filesystem read-only and marking the block device read-only Enabling dmverity hash checking on the root filesystem (\"SIP\" mode) Mounting /tmp , /home and /var with nosuid,nodev Removing Canonical's module signing key Adding usb-storage and other external media to the kernel module deny list Proving the firmware and kernel configuration to remote attestation servers with tpm2-attest","title":"Runtime"},{"location":"threats/#todo","text":"TODO: Flush encryption keys during sleep TODO: VPN config TODO: Prevent network reconfiguration TODO: Device VM separation TODO: Separate /home encryption TODO: Multiparty signatures for higher assurance TODO: Allowed list of USB device IDs. The behaviour of things like the tamper switches and supervisor password are as observed on the Lenovo X1 firmware (and some were fixed after reporting vulnerabilities to Lenovo); other devices may vary and have less secure behaviour.","title":"Todo"},{"location":"threats/#attacks","text":"These changes protect against many local physical and software attacks.","title":"Attacks"},{"location":"threats/#physical-hardware-attacks","text":"A local attacker with physical access to the device can open the device to gain access to the drive, the SPI flash on the mainboard, the Management Engine and CPU chipset, the discrete TPM device, the RAM chips, PCIe buses (such as m.2 slots), etc. Opening the case to modify the flash or modify devices will trip the case tamper switch and prevent the device from booting until the firmware supervisor password is entered. This detects several classes of \"evil maid\" attacks that require physical access. Removing the disk to attempt to rewrite it or image it for offline attacks will trigger both the case tamper switch and the disk tamper switch. The firmware supervisor password is required to reboot, which will allow the user or administrator to detect that the device has been compromised. On Lenovo's recent firmware, the supervisor password is not stored in the SPI flash, but in the EC, and changing it requires the EC to validate the change. This prevents a local attacker from modifying the NVRAM variabels in the SPI flash to bypass the supervisor checks. However, the EC is an open field of security research. On Lenovo's recent firmware, the tamper switch state is stored in the EC, rather than the RTC RAM. This makes it more difficult to bypass the tamper switches since an EC or Bootguard attack is necessary. Exploits against the ME are unlikely to be detectable, although they require a level of expertise to pull off and do not provide persistence. A local attacker could use this to bypass Bootguard and other TPM provided protections. If they also know the TPM PIN and /home encryption password, they can exfiltrate data, but are unlikely to be able to gain persistence without the attack device in place due to the signed dmverity hashes. Changing the firmware in the SPI flash should be detected by Intel Bootguard's verification of the IBB during boot up and result in the device not booting. There are public TOCTOU attacks against Bootguard, so a local attacker can bypass the measured root of trust to boot their unsigned firmware and kernel. As with the ME attacks, if the TPM PIN and /home encryption key are known then data can be exfiltrated, but this does not provide persistence. Writing new platform keys in the SPI flash will result in a TPM unsealing failure since the UEFI secure boot configuration is part of the measured state included in the TPM PCRs. An attack that presents a fake recovery key input dialog can be detected by the tpm2-totp tool. The TPM2 will only generate the 30-second, 6-digit authentication code if the PCRs match the expected value and the administrator can verify it against their authenticator app. With TPM2, the HMAC is computed in the TPM itself, so the secret is never accessible to the operating system. The PCR values in the TPM are not \"secret\", so an adversary with physical access could directly wire to the TPM and provide it with the correct measurements to extend the PCRs to match the signed values. The user PIN is still necessary to unseal the secret and the TPM dictionary attack protections both rate-limit and retry-limit the attacker. Discrete TPM tampering on the LPC bus is not necessarily detectable by this system; an adversary with unlimited internal physical access can also probe sealed secrets. If a TPM PIN is used then the secrets might be brute-forcable, but would require much longer internal access. Functional TPM tampering is out of scope since the fTPM is an application running inside the Intel Management Engine, not a separate device, and the ME is the root of all trust in the system. An adversary with code execution on the ME is able to bypass all of the other platform protections (with maybe the exception of SGX enclaves, although this is not certain). In a \"Coldboot\" attacks on the memory , an attack triggers a reboot in order to boot into their own kernel that doesn't clear memory. Since most of the old contents are still present, this custom kernel can read through memory to look for secrets. This attack is prevented by requiring valid owner signatures on any kernel, and could be additionally prevented by enabling Intel TXT with an enforced DRAM clear, although a physically proximate attacker can turn off those protections by modifying the NVRAM variables during the boot process. In another variant of the coldboot attack, the attacker freezes the RAM chips with cooling spray, removes the physical memory modules and install them into a new system that the attacker controls and that is configured to not clear the memory on power up. This attack is not easily doable on the X1 since all of the RAM is soldered onto mainboard, but is possible against part of the memory on the T490 since it has some of its memory soldered and some on a DIMM. TODO: Can Linux restrict the keys to the hard soldered chips? The encryption keys are stored in RAM even while the system is asleep, which makes the keys potentially available to an attacker with certain resources; it would be worthwhile to consider flushing them prior to entering S3 suspend. This would require modifying the init scripts that handle resume to prompt for the password; the TPM sealed encryption keys are problematic since the TPM state is reloaded during a resume.","title":"Physical hardware attacks"},{"location":"threats/#physical-software-attacks","text":"Modifying the unencrypted kernel or initrd on /boot or attempting to pass in unapproved kernel command line parameters is prevented by the UEFI Secure Boot signature checks. The firmware will not hand control of the system to an unsigned EFI executable, which in this case is the entire kernel, initrd, and command line. This prevents both physical rewriting the disk in another machine, as well as if an attacker escallates to root and remounts /boot as read-write. The boot order NVRAM variable could be modified by an attacker with access to the SPI flash or if they have escallated to root. However, booting from an external device still requires an EFI executable signed by the PK/KEK/db, and since the default signing keys (typically the OEM and Microsoft) have been removed, only images signed the the computer owner's key will be booted from the external USB flash drive. Adversaries might try to gain persistence or weaken security by gaining write access to the unencrypted /boot partition and changing the kernel images. This requires either a root escalation or a tamper switch bypass, but the firmware will deny them peristence by refusing to boot from the modified image since the signature is checked when they are loaded into RAM at boot. There should not be any runtime TOCTOU since the DRAM has been initialized and there is space to store the entire image prior to validating the signature. The adversary might roll back to a prior version of the signed kernel and initrd, with a prior signed version of the PCRs. This is prevented by using monotonic TPM counter in addition to the signature. When a security critical update is available, the TPM counter is incremented and the PCRs are signed with that new value. The TPM will refuse to unseal older sealed data since the counter no longer matches. The TPM counter should be protected against rollback since deleting and re-creating a counter does not reset it to zero, but instead to the highest value that any counter in the TPM has ever reached. Adversaries might try to gain persistence by gaining write access to the encrypted and dmverity protected / filesystem, which requires a kernel escalation since dmverity prohibits writes to the protected block device, or a tamper switch bypass in addition to possession of the TPM disk unsealing keys. However, even with write access, the adversary can not gain persistence since the signed kernel command line and signed initrd enable dmverity hash checking, which will detect any modifications to / . They would also need access to the signing keys to be able to produce a new valid root hash. An adversary might try to gain run time access to the disk encryption key. The PCRs are extended with the booted state so that the TPM will no longer unseal it after the initrd, and root is prevented from reading the key from the Linux kernel keyring, so a kernel escallation is required to gain access to it. TODO: qubes style separate VM for disk and user? Some of the ports on the device, such as Thunderbolt and PCIe, have the ability to DMA in and out of main memory, which would allow a local attacker to connect a device that reads secrets out of unencrypted memory. The safeboot kernel commandline parameter configuration turns on the Intel IOMMU by default, as well as turns off PCIe bus-mastering, both of which should protect against attacks like Thunderspy as well as some classes of malicious devices on the Thunderbolt port or internal Mini-PCIe ports.","title":"Physical software attacks"},{"location":"threats/#software-attacks","text":"An attacker might try to exfiltrate data by plugging in a USB flash drive, which is prevented by adding usb-storage to the deny list. The USB ports could also be turned off in the UEFI Setup , although this would also prevent external keyboards and mice, if they are desired. An attacker with root access could try to load the USB storage module with insmod /lib/modules/..../usb-storage.ko , which bypasses the /etc/modprobe.d/ configuration. This can be prevented by removing the module from the root filesystem. An attacker with root access could download a version of the usb-storage module from the Ubuntu website, which is signed by the Canononical key and can be loaded into a stock kernel since their key is in the default key ring. This is prevented by building a custom kernel with a module signing key that is not stored on the machine. An attacker with root access could try to kexec into a custom kernel that doesn't overwrite the disk encryption key and that doesn't enforce external device access. This is prevented by the Linux kernel lockdown mode (turned on by UEFI Secure Boot mode) , which requires a signature on the new kernel by one of the keys in the UEFI Secure Boot key database, which only contains the public key of the hardware token used to sign the real kernel and initrd. An attacker with root access could try to bypass the module or kexec signature checks by opening /dev/mem or otherwise directly poking into memory to enable the hardware to escalate into kernel mode. The Lockdown patches also disable access to the memory device and prevent root from being able to adjust iopl or other special modes, which should make it more difficult for an attacker to escalate into kernel mode. An attacker with root access might try to use the Linux kernel keyring to read the disk encryption key. This is prevented by enabling lockdown=confidentiality mode , which prevent all kernel memory accesses from user space, and also ensures that the keyrings are not accessible. The attacker would require an additional privilege escalation is required to turn off lockdown. An attacker might try to escalate to root by somehow creating device files or mounting filesystems with SUID binaries. The /etc/fstab entries for /home and /var are configured to not allow such executables. TODO: Prevent network reconfiguration that bypasses mandatory VPN. TODO: ensure that the magic sysctl isn't allowed to bypass various security bits.","title":"Software attacks"},{"location":"threats/#todo_1","text":"TODO: rollback attacks; how to use TPM counters to prevent them TODO: Document rebuilding the kernel TODO: configure allow/deny lists to clean up the module directories. TODO: SELinux config TODO: qubes/secureview separation TODO: /home encryption TODO: TPM PIN TODO: tpm-totp TODO: document how tpm2-attest handles access to remote resources","title":"Todo"},{"location":"tpm2-attest/","text":"tpm2-attest subcommands Usage: tpm2-attest subcommand [options...] For more information see: https://safeboot.dev/attestation/ quote Usage: tpm2-attest quote [nonce] > quote.tar scp quote.tar ... After contacting the remote attestation server to receive the nonce, the machine will generate the endorsement key, endorsement cert, a one-time attestation key, and a signed quote for the all PCRs using that nonce (or the time of day, if no nonce is supplied). The output quote.tar should be sent to the remote side for validation. There is nothing sensitive in the file, so it can be sent in clear text to the server. TODO: the quote should be integrity protected, although while it does not weaken the protocol, it does allow an adversary to create spurious attestation failures. attest Usage: tpm2-attest attest http://server/attest [nonce [pcrs,...]] > secret.txt This will generate a quote for the nonce (or the current time if none is specified) and for the PCRs listed in the $QUOTE_PCRS environment variable. It will then send the quote to a simple attestation server, which will validate the quote and reply with a sealed message that can only be decrypted by this TPM on this boot. No validation of the attestation server is done. verify Usage: tpm2-attest verify quote.tar [nonce [ca-path]] This will validate that the quote was signed with the attestation key with the provided nonce, and verify that the endorsement key from a valid TPM. It outputs, but does not validate the event log; use tpm2-attest eventlog-verify once the known PCRs are available, or use a more complex validation scheme. If the nonce is not specified, the one in the quote file will be used, although this opens up the possibility of a replay attack. The QUOTE_MAX_AGE can be used to ensure that the quote is fresh. If the ca-path is not specified, the system one will be used. The output on stdout is yaml formatted with the sha256 hash of the DER format EK certificate, the validated quote PCRs, and the unvalidated eventlog PCRs. eventlog Usage: tpm2-attest eventlog [eventlog.bin] This will read and parse the TPM2 eventlog. If no file is specified, the default Linux one will be parsed. If - is specified, the eventlog will be read from stdin. eventlog-verify Usage: tpm2-attest eventlog-verify quote.tar [good-pcrs.txt] This will verify that the PCRs included in the quote match the TPM event log, and if good-prcs.txt are passed in that they match those as well. ek-verify Usage: tpm2-attest ek-verify quote.tar ca-path This will validate that the endorsement key came from a valid TPM. The TPM endorsement key is signed by the manufacturer OEM key, which is in turn signed by a trusted root CA. Before trusting an attestation it is necessary to validate this chain of signatures to ensure that it came from a legitimate TPM, otherwise an attacker could send a quote that has a fake key and decrypt the message in software. The ca-path should contain a file named roots.pem with the trusted root keys and have the hash symlinks created by c_rehash . stdout is the sha256 hash of the DER format EK certificate. quote-verify Usage: tpm2-attest quote-verify quote.tar [nonce] This command checks that the quote includes the given nonce and was signed by the public attestation key (AK) in the quote file. This also check the attributes of the AK to ensure that it has the correct bits set ( fixedtpm , stclear , etc). NOTE: This does not verify that the AK came from a valid TPM. See tpm2-attest verify for the full validation. If the nonce is not specified on the command line, the one in the quote file will be used. Note that this is a potential for a replay attack -- the remote attestation server should keep track of which nonce it used for this quote so that it can verify that the quote is actually live. stdout is the yaml formatted tpm2 checkquote , which can be used to validate the eventlog PCRs. seal Usage: echo secret | tpm2-attest seal quote.tar > cipher.bin After a attested quote has been validated, an encrypted reply is sent to the machine with a sealed secret, which can be of arbitrary length, that is encrypted with a random key. This random key is encrypted with that machines endorsment key ( ek.crt ), along with the name of the attestation key used to sign the quote. The TPM will not decrypt the message key unless the attestation key was one that it generated. The sealed.tar file should be sent back to the device being attested; it can then run tpm2-attest unseal < sealed.tar > secret.txt to extract the sealed secret (which may be of arbitrary length). unseal Usage: cat sealed.tar | tpm2-attest unseal > secret.txt When the remote attestation has been successful, the remote machine will reply with an encrypted blob that is only unsealable by this TPM if and only if the EK matches and the AK is one that it generated. verify-and-seal Usage: tpm2-attest verify-and-seal quote.tar [nonce [pcrs]] < secret.txt > sealed.tar If the nonce is not specified on the command line, the one in the quote file will be used. Note that this is a potential for a replay attack -- the remote attestation server should keep track of which nonce it used for this quote so that it can verify that the quote is actually live. ek-sign Usage: tpm2-attest ek-sign < ek.pem > ek.crt [/CN=device-name/] Some TPMs do not include manufacturer signed endorsement key certificates, so it is necessary to extract the EK and sign it with a trusted key. This will produce ek.crt , signed with the safeboot key. The signing operation can be done out-of-band on a different machine. For Google Cloud ShieldedVM machines see: https://cloud.google.com/security/shielded-cloud/retrieving-endorsement-key Usually the EK public components can be extracted from the TPM, signed, and the resulting signed ek.crt can be stored back into the TPM nvram. Note that this will erase an existing OEM cert if you have one! # on the device tpm2-attest ek-crt > ek.pem # on the server tpm2-attest ek-sign < ek.pem > ek.crt /CN=device/OU=example.org/ # on the device again tpm2-attest ek-crt ek.crt ek-crt Usage: tpm2-attest ek-crt > ek.pem # Export the TPM EK in PEM format (not cert) or tpm2-attest ek-crt ek.crt # Import a signed cert for the EK in DER format Export the TPM RSA endorsement key for signing by a CA or import a signed endorsement key certificate into the TPM NVRAM at the well-known handle. See tpm2-attest ek-sign for more details.","title":"tpm2-attest subcommands"},{"location":"tpm2-attest/#tpm2-attest-subcommands","text":"Usage: tpm2-attest subcommand [options...] For more information see: https://safeboot.dev/attestation/","title":"tpm2-attest subcommands"},{"location":"tpm2-attest/#quote","text":"Usage: tpm2-attest quote [nonce] > quote.tar scp quote.tar ... After contacting the remote attestation server to receive the nonce, the machine will generate the endorsement key, endorsement cert, a one-time attestation key, and a signed quote for the all PCRs using that nonce (or the time of day, if no nonce is supplied). The output quote.tar should be sent to the remote side for validation. There is nothing sensitive in the file, so it can be sent in clear text to the server. TODO: the quote should be integrity protected, although while it does not weaken the protocol, it does allow an adversary to create spurious attestation failures.","title":"quote"},{"location":"tpm2-attest/#attest","text":"Usage: tpm2-attest attest http://server/attest [nonce [pcrs,...]] > secret.txt This will generate a quote for the nonce (or the current time if none is specified) and for the PCRs listed in the $QUOTE_PCRS environment variable. It will then send the quote to a simple attestation server, which will validate the quote and reply with a sealed message that can only be decrypted by this TPM on this boot. No validation of the attestation server is done.","title":"attest"},{"location":"tpm2-attest/#verify","text":"Usage: tpm2-attest verify quote.tar [nonce [ca-path]] This will validate that the quote was signed with the attestation key with the provided nonce, and verify that the endorsement key from a valid TPM. It outputs, but does not validate the event log; use tpm2-attest eventlog-verify once the known PCRs are available, or use a more complex validation scheme. If the nonce is not specified, the one in the quote file will be used, although this opens up the possibility of a replay attack. The QUOTE_MAX_AGE can be used to ensure that the quote is fresh. If the ca-path is not specified, the system one will be used. The output on stdout is yaml formatted with the sha256 hash of the DER format EK certificate, the validated quote PCRs, and the unvalidated eventlog PCRs.","title":"verify"},{"location":"tpm2-attest/#eventlog","text":"Usage: tpm2-attest eventlog [eventlog.bin] This will read and parse the TPM2 eventlog. If no file is specified, the default Linux one will be parsed. If - is specified, the eventlog will be read from stdin.","title":"eventlog"},{"location":"tpm2-attest/#eventlog-verify","text":"Usage: tpm2-attest eventlog-verify quote.tar [good-pcrs.txt] This will verify that the PCRs included in the quote match the TPM event log, and if good-prcs.txt are passed in that they match those as well.","title":"eventlog-verify"},{"location":"tpm2-attest/#ek-verify","text":"Usage: tpm2-attest ek-verify quote.tar ca-path This will validate that the endorsement key came from a valid TPM. The TPM endorsement key is signed by the manufacturer OEM key, which is in turn signed by a trusted root CA. Before trusting an attestation it is necessary to validate this chain of signatures to ensure that it came from a legitimate TPM, otherwise an attacker could send a quote that has a fake key and decrypt the message in software. The ca-path should contain a file named roots.pem with the trusted root keys and have the hash symlinks created by c_rehash . stdout is the sha256 hash of the DER format EK certificate.","title":"ek-verify"},{"location":"tpm2-attest/#quote-verify","text":"Usage: tpm2-attest quote-verify quote.tar [nonce] This command checks that the quote includes the given nonce and was signed by the public attestation key (AK) in the quote file. This also check the attributes of the AK to ensure that it has the correct bits set ( fixedtpm , stclear , etc). NOTE: This does not verify that the AK came from a valid TPM. See tpm2-attest verify for the full validation. If the nonce is not specified on the command line, the one in the quote file will be used. Note that this is a potential for a replay attack -- the remote attestation server should keep track of which nonce it used for this quote so that it can verify that the quote is actually live. stdout is the yaml formatted tpm2 checkquote , which can be used to validate the eventlog PCRs.","title":"quote-verify"},{"location":"tpm2-attest/#seal","text":"Usage: echo secret | tpm2-attest seal quote.tar > cipher.bin After a attested quote has been validated, an encrypted reply is sent to the machine with a sealed secret, which can be of arbitrary length, that is encrypted with a random key. This random key is encrypted with that machines endorsment key ( ek.crt ), along with the name of the attestation key used to sign the quote. The TPM will not decrypt the message key unless the attestation key was one that it generated. The sealed.tar file should be sent back to the device being attested; it can then run tpm2-attest unseal < sealed.tar > secret.txt to extract the sealed secret (which may be of arbitrary length).","title":"seal"},{"location":"tpm2-attest/#unseal","text":"Usage: cat sealed.tar | tpm2-attest unseal > secret.txt When the remote attestation has been successful, the remote machine will reply with an encrypted blob that is only unsealable by this TPM if and only if the EK matches and the AK is one that it generated.","title":"unseal"},{"location":"tpm2-attest/#verify-and-seal","text":"Usage: tpm2-attest verify-and-seal quote.tar [nonce [pcrs]] < secret.txt > sealed.tar If the nonce is not specified on the command line, the one in the quote file will be used. Note that this is a potential for a replay attack -- the remote attestation server should keep track of which nonce it used for this quote so that it can verify that the quote is actually live.","title":"verify-and-seal"},{"location":"tpm2-attest/#ek-sign","text":"Usage: tpm2-attest ek-sign < ek.pem > ek.crt [/CN=device-name/] Some TPMs do not include manufacturer signed endorsement key certificates, so it is necessary to extract the EK and sign it with a trusted key. This will produce ek.crt , signed with the safeboot key. The signing operation can be done out-of-band on a different machine. For Google Cloud ShieldedVM machines see: https://cloud.google.com/security/shielded-cloud/retrieving-endorsement-key Usually the EK public components can be extracted from the TPM, signed, and the resulting signed ek.crt can be stored back into the TPM nvram. Note that this will erase an existing OEM cert if you have one! # on the device tpm2-attest ek-crt > ek.pem # on the server tpm2-attest ek-sign < ek.pem > ek.crt /CN=device/OU=example.org/ # on the device again tpm2-attest ek-crt ek.crt","title":"ek-sign"},{"location":"tpm2-attest/#ek-crt","text":"Usage: tpm2-attest ek-crt > ek.pem # Export the TPM EK in PEM format (not cert) or tpm2-attest ek-crt ek.crt # Import a signed cert for the EK in DER format Export the TPM RSA endorsement key for signing by a CA or import a signed endorsement key certificate into the TPM NVRAM at the well-known handle. See tpm2-attest ek-sign for more details.","title":"ek-crt"}]}